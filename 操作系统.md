### 操作系统

#### 概述

1. 功能：软硬件资源的管理者，向上层提供服务(程序接口即系统调用)，对硬件及其的扩展，是一种系统软件
2. 基本特征：并发(通过分时实现)，共享(互斥，同时)，虚拟(时分-虚拟处理器，空分-虚拟存储器)，异步(进程以不可预知的速度向前)
3. 发展和分类：手工操作阶段，批处理阶段(单道和多道，没有人机交互)，分时(不能处理紧急任务)，实时(硬实时-严格要求导弹控制系统，软实时)，分布式，个人计算机
4. 层次结构：1裸机  2时钟管理，中断管理，原语(设备驱动，CPU切换，具有原子性)  3进程管理，内存管理，设备管理  4非内核功能
5. 内核态和用户态，特权指令和非特权指令；  内核态->用户态：执行一条特权指令-修改PSW标志位 用户态->内核态：由中断引发，硬件自动完成该过程，系统强行夺回CPU的使用权
6. 大内核：效率高，组织结构混乱，难以维护(进程管理，内存管理和设备管理也在内核态)；  微内核：组织结构清晰，方便维护，效率低
7. 中断是让操作系统内核夺回CPU使用权的唯一途径，分为内中断(异常，与当前指令有关)和外中断(狭义中断，与当前指令无关，如时钟中断，I/O中断请求)
8. 系统调用：操作系统提供给应用程序使用的接口，应用程序可以使用系统调用来获得操作系统内核的服务，防止用户非法操作，分为设备管理，文件管理，内存管理，进程控制，进程通信

#### 进程管理

1. 是程序的一次执行过程；进程实体：PCB(记录各种信息)，程序段，数据段(运行过程中产生的数据)
2. 进程是进程实体的运行过程，是动态的，是系统进行资源分配和调度的一个独立单位
3. PID(Process ID)，保存在PCB(Process Control Block)进程控制块中，PCB是进程存在的唯一标志
4. 特征：动态性(最基本)，并发性，独立性，异步性，结构性
5. 进程的状态：运行态，就绪态，阻塞态，创建态，终止态；PCB中用state变量表示；运行态->阻塞态是自身的主动行为，进程用系统调用的方式申请资源或等待事件发生
6. 不同状态的链接方式：通过指针和队列
7. 进程控制：实现进程状态的转换，用原语实现；原语用“关中断指令”和“开中断指令”两个特权指令实现原子性(关中断后就不再检查其他中断信号了)
8. 进程控制相关原语：1更新PCB的信息 2将PCB插入合适队列 3分配/回收资源
9. 进程通信：进程之间的信息交换，各进程拥有的内存地址空间相互独立，所以需要操作系统支持； 方法：1共享存储(申请一个共享存储区，访问互斥)  2消息传递(以格式化的消息为单位，通过发送/接收消息两个原语进行数据交换)  3管道通信(管道是一个特殊的共享文件，在内存开辟一个大小固定的内存缓冲区，单向，队列先进先出)
10. 进程是资源分配的最小单位，线程是CPU调度的最小单位，线程是程序执行流的最小单位
11. 线程实现方式：用户级线程(一个线程被阻塞整个进程都会被阻塞)；内核级线程(由操作系统支持的线程，线程切换由操作系统内核完成，因此需要切换到内核态，成本高)：分为一对一，多对一，多对多(用户视角个数>操作系统视角个数)
12. 操作系统只看得见内核级线程，只有内核级线程才是CPU分配的单位，用户级一直是同一个CPU
13. 调度：三层调度：高级调度(外存->内存；无->创建态->就绪态)；中级调度(外存->内存，挂起态->就绪态/阻塞挂起->阻塞态)；低级调度(内存->CPU，就绪态->运行态)
14. 作业/内存/进程调度；作业可以由多个进程组成；
15. 五个状态可以拓展就绪挂起和阻塞挂起，挂起是指直接将进程映像调到外存了
16. 进程调度的时机：主动放弃，被动放弃(时间片用完，中断，更优先级进入就绪队列)；不能切换的时机：中断，原语，操作系统内核程序临界区(访问临界资源，普通临界区如打印机可以调度)
17. 调度算法评价指标：CPU利用率，系统吞吐量(作业)，周转时间(作业)，等待时间，响应时间
18. 调度算法：1先来先服务  2短作业优先  3最高响应比优先  都是非抢占式，对短作业和长作业的平衡，适用于早期的批处理系统
19. 1时间片轮转  2优先级调度算法  3多级反馈队列调度算法  都是抢占式  适用于交互式系统
20. 进程同步：解决异步问题，各进程遵循一定先后顺序   进程互斥：临界资源的访问需要互斥     进程互斥需遵循的原则：空闲让进，忙则等待，有限等待，让权等待(自己无法执行关键部分时放权CPU)
21. 进程互斥的软件实现方法：1单标志法 turn=0/1  2双标志先检查法flag\[0][1]=true/false(违反忙则等待，可能存在死锁，因为进入区的检查和上锁操作无法一气呵成)   3双标志后检查法(违背空闲让进和有限等待，产生饥饿现象)    4Peterson算法  (主动争取，主动谦让，检查对方是否想用，先谦让的那个先用；未遵循让权等待)    所有的解决方案都无法实现让权等待
22. 进程互斥的硬件实现方法：1中断屏蔽法(开/关中断特权指令实现，不适合多处理机)； 2TestAndSet指令(TSL): 将上锁和检查用硬件方式变成原子操作     3Swap(Exchange)同TSL
23. 互斥锁：缺点 忙等待，适用于多处理器机器；需要连续循环忙等的互斥锁都可称为 自旋锁
24. 信号量机制：整形信号量(wait(s–),signal(S++)不满足让权等待，记录型信号量满足让权等待；wait()原语实现了检查和上锁一气呵成
25. 记录型信号量：利用一对原语：wait(S)和signal(S)简称P,V操作(荷兰语)，S是信号量(资源数量) wait(S–, 若S<0 则block(S)原语进入S的阻塞队列中)  signal(S++, wakeup()原语唤醒为就绪态)
26. P(S)  申请资源S, 如果资源不够就阻塞等待； V(S)  释放资源S，如果有进程在等待该资源就唤醒
27. 信号量机制实现进程互斥/进程同步/进程的前驱关系：
28. 互斥：semaphore mutex=1; P1+P2(){P(mutex, 临界区代码段,V(mutex))}；初始为1
29. 同步：设置同步信号量S=0，前操作之后执行V(s), 后操作之前执行P(S)   前V后P   P1是V, P2是P；初始为0
30. 实现前驱关系：为每一对前驱关系都设计 29同步信号量
31. 生产者消费者问题：   分析前驱关系，每一个前驱都对应一个资源；代码都是P在前，V在后,  事件：生产,P(empty)，放入临界区,V(full)；  拿出临界区，P(full)，消费, V(empty)
32. 多生产者 多消费者问题  从事件的角度思考，盘子plate=1
33. 吸烟者问题：三个抽烟者进程和一个供应者进程  offer1/2/3   finish   int(i%3)轮流
34. 读者-写者问题：写和读，写和写不能同时访问   第一个读者加锁，最后一个读者解锁(使得读和读可以不互斥)
35. 管程  信号量机制问题：编写程序困难，易出错；管程类似于private属性开放get/set方法并加锁同步的对象
36. 进程只能通过管程提供的特定入口才能访问共享数据，每次只允许一个进程在管程内执行，各进程互斥访问管程的特性是编译器决定的
37. 死锁：各进程互相等待对方手里的资源，造成各进程都阻塞无法向前推进 ；原因：对不可剥夺资源的不合理分配
38. 死锁，饥饿，死循环：前两个是操作系统要解决的问题，死循环是编写程序解决的
39. 死锁的必要条件：互斥条件，不剥夺条件，请求和保持条件，循环等待条件
40. 死锁处理策略：1预防，破坏四个必要条件  2避免 银行家算法  3检测和解除  操作系统系统负责；
41. 不允许死锁发生：1静态策略 预防死锁   2动态测量  避免死锁  允许死锁发生：死锁的检测和解除
42. 死锁的避免：银行家算法：在进程提出资源申请时，预判此次分配是否会导致系统进入不安全状态，如果会就不答应这次请求让其阻塞等待
43. 思路：尝试找出一个让所有进程都加入的安全序列；不安全未必死锁，可能会提前归还资源
44. 死锁的检测：数据结构 资源分配图：两种结点(进程结点，资源结点)；两种边(请求边和分配边) 算法：依次消除与不阻塞进程相连的边，直到无边可消，若不能完全消除边说明发生了死锁
45. 死锁的解除：资源剥夺法，撤销进程法，进程回退法

#### 内存管理

1. 编译，链接(地址重定向(完整的逻辑地址)，符号统一)，装入(形成物理地址)
2. 三种装入方式：绝对装入(编译时产生绝对地址)，可重定位装入(转入时转换为绝对地址)，动态运行时装入(运行时转换，需设置重定位寄存器)；三种链接方式：静态，装入时动态，运行时动态
3. 内存管理的概念：1内存空间的分配与回收  2内存空间的扩充(实现虚拟性)  3地址转换  4存储保护(1设置上下限寄存器 2利用重定位寄存器、界地址寄存器判断)
4. 内存扩充：覆盖技术和交换技术   覆盖：内存分为固定区和覆盖区，需要程序自己声明覆盖结构    交换：将内存中某些进程暂时换出外存(磁盘分为文件区和对换区(连续分配方式)，PCB常驻内存) 
5. 内存空间的分配与回收：可分为连续分配管理方式和非连续
6. 连续：单一连续分配(单道程序，无外部碎片，有内部碎片)，固定分区分配(无外有内)，动态分区分配(无内部碎片，有外部碎片，使用紧凑技术解决)
7. 动态分区分配算法：首次适应(顺序查找，算法开销小，综合性能最好)，最佳适应(优先找小的分区，容易产生极小碎片，开销大)，最坏适应(优先找大的空间，大分区容易用完，开销大)，临近适应(递增次序，会使高地址的大分区也被用完，开销小)
8. 非连续分配方式：可分为基本分页存储管理，基本分段存储管理，段页式存储管理
9. 基本分页存储管理：内存分为一个个大小相同的分区：页框，编号为页框号；进程的逻辑地址也分为页/页面，编号为页号；  两者用页表联系起来，页表大小bit能容纳多少个页框就行(3B=3\*8=24能容纳2\^20个页框)页表只需要存储页框号(第几个)，页号自动计算出来
10. 逻辑地址(十进制)可拆分为(页号，页内偏移量)=(逻辑地址/页面大小，逻辑地址%页面大小)
11. 基本地址变换机构：地址变换过程
12. 具有快表的地址变换机构：快表TLB: 是用来存放最近访问的页表项的副本(只有)，高速缓存
13. 局部性原理：时间/空间；   先访问快表，块表未命中再访问内存
14. 外存，内存，(Cache高速缓存，寄存器)CPU内部
15. 两级列表：单极列表存在问题：1页表必须连续存放，所以也会占用很多连续的页框；2没必要整个页表常驻内存
16. 1(一级列号，二级列号，页内偏移量)， 2在需要访问页面的时候再把页面调入内存(虚拟存储技术)，页表增加一个标志位表示是否已经调入内存
17. 基本分段存储管理：进程的地址空间：按照程序自身的逻辑关系划分为若干个段；内存以段为单位进行分配，每个段在内存占据连续空间，段与段之间可以不相邻
18. 段表：段表项记录该段的起始位置和段的长度，每个段表项的长度是相同的
19. 页是消息的物理单位，系统行为提高内存利用率，对用户不可见；段是信息的逻辑单位，满足用户需求，对用户是可见的，编程时需要显式给出段名；
20. 分页地址空间是一维的(逻辑地址)，分段地址空间是二维的，需要给出段名和段内地址
21. 分段比分页更容易实现信息的共享和保护(比如生产者消费者模型，不同代码段的权限应该不同)
22. 分页管理：内存利用率高，不会产生外部碎片，但是不方便按照逻辑模块实现信息的共享和保护，分段相反
23. 段页式管理，分页由操作系统完成，程序只需给出分段
24. 虚拟内存管理：解决1一次性：作业必须一次性调入内存才开始允许  2驻留性：驻留大量暂时用不到的数据；   特征：多次性，对换性，虚拟性；   实现：请求分页/分段/段页
25. 请求调页功能：当访问信息不在内存式，由操作系统负责从外存调入内存；页面置换功能：当内存空间不够时，换出到外存；
26. 请求分页相比基本分页：页表增加表项，缺页中断(内中断，和程序本身有关)
27. 页面置换算法：1最佳置换算法OPT(淘汰最长时间内不再被访问的页面，无法实现)  2先进先出FIFO (淘汰最早进入内存的页面，唯一会产生Beledy异常:物理块数(容纳页面数)增大，缺页次数反而增加) 3最近最久未使用LRU(性能好，实现困难开销大)  4时钟置换法CLOCK(最近未用算法)：循环判断最近未访问的页面   5改进CLOCK: 加一个未修改(不需要写回外存)
28. 页面分配策略：驻留集(给进程分配的内存块的大小)； 分配和置换：固定分配vs可变分配；局部置换vs全局置换  两两组合；  抖动(颠簸)现象：页面频繁换入换出，原因：分配给进程的内存块不够
29. 内存映射文件：进程使用系统调用，将文件映射到进程的虚拟地址空间，以访问内存的方式读写文件，关闭文件时会写回磁盘     优点：文件数据的读写都由操作系统完成，效率可以优化；不同进程实现数据共享

#### 面试小抄

1. 进程和线程的区别：1调度：进程是系统进行资源分配和调度的基本单位，线程是程序执行的基本单位；2切换：线程上下文切换快得多；3拥有资源：进程是拥有资源的一个独立单位，线程不拥有，但可以访问属于进程的资源；4系统开销：创建或撤销进程是，系统锁付出的开销(分配和回收系统资源)大于线程；5通信：进程通信需要使用特殊机制，线程由于共享相同的内存空间，可以直接访问共享数据，通信更加方便；6安全性：线程相互隔离，一个进程的崩溃不会影响其他进程，线程可能会影响整个进程的稳定性
2. 为什么虚拟地址空间切换会比较耗时：进程将虚拟地址转化为物理地址需要查找页表，通常会用高速缓存(TLB)来缓存，进程切换后页表也要切换，TLB失效，Cache失效导致命中率降低；线程不需要切换地址空间
3. 进程调度算法：先来先服务，短作业优先，最高响应比，时间片轮转，优先级调度算法，多级反馈队列调度算法
4. 进程间有哪些通信方式：管道通信(半双工，单向流动，在父子进程关系使用)；信号量(计数器，控制多个线程对共享资源的访问，锁机制)；消息队列(消息的链表，存放在内核中并由消息标识符标识)；共享内存(最快，进程创建)
5. 死锁：指两个或多个进程在争夺系统资源时，由于互相等待对方释放资源而无法继续执行的状态
6. 互斥(一次性申请所有资源)，不剥夺(主动释放)，请求保持，循环等待(按序申请资源，稀少的资源用大编号，只有获得小编号才能申请较大编号的资源)；预防，避免，检测和解除
7. 虚拟内存：每个进程加载时会分配一个连续虚拟地址空间，非真实存在，而是通过映射与实际地址空间对应，看起来连续并认为拥有足够内存
8. 需要虚拟内存的原因：内存扩展，内存隔离，物理内存管理(动态加载)，页面交换(写入磁盘)，内存映射文件(将文件映射到内存中方便读写)
9. 内存分段：将程序的内存空间分为不同的逻辑段，每个段对应一个功能模块，按照逻辑模块实现信息的共享和保护，但如果段长过大，为其分配很大的连续空间会很不方便，会产生外部碎片
10. 内存分页，将逻辑地址和物理内存分成固定大小的页，提高内存利用率
11. 用户态和核心态是操作系统两种不同的执行模式，用于控制进程或程序对计算机硬件资源的访问权限和操作范围；
12. 用户态只能访问受限的资源和执行受限的指令集，不能访问操作系统的核心部分和硬件资源，CPU不允许独占；核心态允许执行特权指令和访问核心部分，是操作系统的特权级别
13. 页面置换算法：LRU(最近久未使用，Last Recently Used)算法：基于页面的使用历史，通过选择最长时间未被使用的页面进行置换，性能好，实现困难开销大
14. FIFO:最先进入内存的页面最先被置换出去;    OPT:根据未来的页面访问情况，选择最长时间内不会被访问到的页面进行置换
15. 时钟算法：使用指针在环形链表上遍历，检查页面是否被访问过，没有就置换(改进：增加修改位)
16. 进程同步：多个并发执行的进程之间协调和管理他们的执行顺序，保证他们按照一定的顺序或时间间隔执行；    进程互斥：某一时刻只允许一个进程访问共享资源
17. 信号量机制和PV操作；临界区，互斥锁，条件变量(condition,  await/signal)
18. 中断和异常：中断(突发事件)是由外部设备或其他处理器产生的，可以被屏蔽或禁止；异常是由CPU内部产生的，不能被屏蔽或禁止；
19. 中断作用：1外设异步通知CPU；2CPU之间发送消息；3处理CPU异常(自己发送，除0，缺页中断；trap, fault, abort)；4系统调用
20. 介绍几种典型的锁：两个基础锁：互斥锁，自旋锁；其他锁都是基于这两个锁：读写锁，悲观锁，乐观锁
21. 进程间的管道通信：

    1. 管道，内核中的一串缓存，从管道的一端写入数据，另一端读取，数据只能单向流动，遵循先进先出的原则；分为匿名管道(具有亲缘关系的进程如父子进程)，和命名管道(允许无亲缘关系的进程通信)；管道的效率低，不适合进程间频繁地交换数据
    2. 信号：用于通知接受进程某件事情发生了，主要用于处理异步事件
    3. 消息队列：保存在内核的消息链表，按照消息的类型进行消息传递，具有较高的可靠性和稳定性；缺点：消息体有一个最大长度的限制，不适合比较大的数据传输，存在用户态和内核态之间的数据拷贝开销
    4. 共享内存：一个给定的内存区，一个进程写入的东西其他进程马上能看到，最快的进程间通信方式，针对其他通信方式运行效率低设计的；缺点：当多进程竞争同一个共享资源时，会造成数据错乱的问题
    5. 信号量：本质上是一个计数器，用来控制对共享资源的访问数量；PV操作
    6. 套接字Socket：提供网络通信的端点，可以让不同机器上运行的进程之间进行双向通信
22. 





























#### 硬件结构

1. CPU执行指令的四个阶段(四级流水线)：Fetch，Decoder，Execute，Store 指令周期
2. 寄存器：通用寄存器，程序计数器(存放下一条执行指令的地址)，指令寄存器(存放指令本身)
3. 地址总线指定内存地址，控制总线控制读写命令，数据总线传输数据
4. 存储器类型：寄存器，L1/2/3 Cache，内存，硬盘；对应大脑，短期长期记忆，桌子，图书馆
5. Cache使用SRAM静态随机存储器，掉电数据丢失，内存使用DRAM动态(数据存储在电容会不断漏电，需要定时刷新数据才能存储起来)
6. 存储器层次结构(相邻层存储器打交道)，分级的目的是要构造缓存体系
7. CPU和内存的访问性能相差越来越多，引入CPU Cache，L1Cache包括数据缓存和指令缓存，Cache由缓存块组成，命中缓存指不需要读取内存直接读Cache
8. 数据写入Cache后如何同步到内存，写直达，写回(Cache Block被替换时写入内存)
9. CPU多核心带来的缓存一致性问题，需要做到两点：写传播(全部Cache一起更新)，事务的串行化(保证相同顺序的数据变化)，总线嗅探不能保证后者，MESI协议(四个状态字母缩写，已修改，独占，共享，已失效)也基于总线嗅探，独立维护状态，替换前同步到内存
10. 伪共享：同一个Cache Line的不相关变量无意义变更状态和更新数据，用空间换时间
11. CPU如何选择线程：调度类(优先级区分)
12. Linux为了解决中断处理程序执行过长和中断丢失的问题，将中断分为上半部分和下半部分，上半部分用来快速处理中断，会暂时关闭中断请求，下半部分用来延迟处理上半部分未完成的工作，一般以内核线程的方式运行
13. 上半部直接处理硬件请求，也就是硬中断，由硬件触发中断，主要是负责耗时短的工作，特点是快速执行；下半部是由内核触发，也就说软中断，由内核触发中断，主要是负责异步处理上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；
14. 负数以补码方式(取反加一)表示原因：使得负数的加减法操作和正数加减法操作一样，统一正负数加减操作，否则就需要多一步操作判断是否复数然后转换正负再相加
15. 0.1的二进制是无限循环的，由于计算机资源有限，只能用近似值表示最大化接近，会造成精度缺失的情况
16. 浮点数储存小数，科学计数法的尾数(去掉1)和指数，标准形式为符号位，指数位，尾数

#### 操作系统结构

1. 内核作为应用连接硬件设备的桥梁，需要提供4个基本能力：管理进程线程，管理内存，管理硬件设备，提供系统调用；内核态用户态
2. 宏内核(Linux)，微内核，混合内核(windows)，可执行文件格式也不同

#### 内存管理

1. 操作系统为每个进程分配独立的一套虚拟地址，提供一种机制将不同进程的虚拟地址和不同内存的物理地址映射起来，方式：内存分段和内存分页；目的：为了使多进程环境下进程之间的内存地址不受影响相互隔离

2. 内存分段(段选择因子，段内偏移量)不足：内存碎片–>内存交换的效率低   堆栈数据代码段

3. 内存分页：把整个虚拟和物理内存空间切成一段段固定尺寸的大小，维护一张页表；内存交换(只需要交换少数几个页，内存到硬盘)效率高，在加载程序时不真的把也加载到物理内存，只在程序运行中加载

4. 多级页表，解决单级页表占用内存过多(需要的时候才创建二级页表)     每个进程都有4GB虚拟地址空间，未使用的空间对应的页表没有分配，分配的如果一定时间未访问也会从物理内存转出到硬盘

5. 分段和分页组合：段页式内存管理，地址结构由段号，段内页号和业内偏移组成

6. 总结：为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套**虚拟地址空间**，每个程序只关心自己的虚拟地址就可以，实际上大家的虚拟地址都是一样的，但分布到物理地址内存是不一样的。作为程序，也不用关心物理地址的事情。

   每个进程都有自己的虚拟空间，而物理内存只有一个，所以当启用了大量的进程，物理内存必然会很紧张，于是操作系统会通过**内存交换**技术，把不常使用的内存暂时存放到硬盘（换出），在需要的时候再装载回物理内存（换入）。

   那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。

   那么对于虚拟地址与物理地址的映射关系，可以有**分段**和**分页**的方式，同时两者结合都是可以的。

   内存分段是根据程序的逻辑角度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的段，同时是一块连续的空间。但是每个段的大小都不是统一的，这就会导致外部内存碎片和内存交换效率低的问题。

   于是，就出现了内存分页，把虚拟空间和物理空间分成大小固定的页，如在 Linux 系统中，每一页的大小为 `4KB`。由于分了页后，就不会产生细小的内存碎片，解决了内存分段的外部内存碎片问题。同时在内存交换的时候，写入硬盘也就一个页或几个页，这就大大提高了内存交换的效率。

   再来，为了解决简单分页产生的页表过大的问题，就有了**多级页表**，它解决了空间上的问题，但这就会导致 CPU 在寻址的过程中，需要有很多层表参与，加大了时间上的开销。于是根据程序的**局部性原理**，在 CPU 芯片中加入了 **TLB**，负责缓存最近常被访问的页表项，大大提高了地址的转换速度。

   **Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理**。于是 Linux 就把所有段的基地址设为 `0`，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。

   另外，Linux 系统中虚拟空间分布可分为**用户态**和**内核态**两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。

   > 最后，说下虚拟内存有什么作用？

   - 第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
   - 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
   - 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。

7. 

