### Redis

数据结构，线程模型，持久化，Redis集群，过期删除与内存淘汰，缓存异常，IO模型，事务

##### 数据结构

1. Redis是一种基于内存的数据库，读写操作在内存中完成，所以读写数据非常快，常用于缓存，消息队列，分布式锁；对数据类型的操作都是原子性的，因为执行命令是单线程负责，不存在并发竞争的问题；Redis还支持事务，持久化，多种集群方案(主从复制模式，哨兵模式，切片机群模式)，发布/订阅模式，内存淘汰机制，过期删除机制
2. 数据结构：SDS简单动态字符串(自动扩容)，IntSet(元素唯一，有序性，长度可变，int类型可升级)，Dict(Dict包含两个哈希表，指向数组，底层为数组加链表)，ZipList(连续空间双向链表，记录上一节点和本节点长度代替指针连接)，QuickList(节点为ZipList的双向链表，控制ZipList大小解决连续内存空间申请效率问题)，SkipList(跳表，元素顺序排列，含多层指针)，RedisObject
3. String使用SDS，list使用quickList，hash使用listpack和哈希表，set使用哈希表和IntSet，zset使用listpack和跳表；zipList被listpack取代
4. HyperLogLog：用于统计基数(不重复元素)，在输入元素的数量非常多时，计算基数所需的空间是固定的；其统计规则是基于概率完成的，给出的统计结果误差率为0.81%
5. Bitmap：bit数组，统计数据的二值状态
6. Redis运行比较快的原因：
   - 数据存储在内存中，能够进行快速的读写操作
   - 单线程处理请求，可以避免线程切换和锁竞争等问题，提高CPU的利用率和性能
   - 高效的数据结构，能够快速地进行插入删除查找等操作
   - 非阻塞IO，使用epoll实现的多路复用IO技术，不在IO上浪费过多时间
   - 高效的持久化机制，在不影响性能的情况下保证数据的安全
7. 为什么要用Redis做缓存：1从高并发上来说，直接操作缓存能够承受的请求是远远大于直接访问数据库的，将数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库；2从高性能上来说，操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据

##### Redis线程模型-单线程处理请求

1. Redis单线程指的是[接收客户端请求–>解析请求–>进行数据读写操作–>发送数据给客户端] 这个过程(单线程处理请求)是由一个线程(主线程)完成；Redis程序不是单线程，启动时会启动后台线程(关闭文件，AOF刷盘，释放内存 三个后台线程，操作耗时)；      生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可
2. 为什么使用单线程：1CPU并不是制约Redis性能表现的瓶颈所在，过多是受到内存大小和网络IO的限制；2使用多线程会导致过多的上下文切换，开销增大；3面临线程安全问题，比如要引入线程锁，实现复杂度高，性能降低

##### 持久化

1. Redis保证数据不丢失的主要手段有两个：持久化和集群运行；持久化：重用Redis数据，或者防止系统故障

2. 三种数据持久化的方式：

   - 1AOF日志：Append Only File文件追加持久化，记录所有写操作命令，并以文本的形式追加到文件中

   * 2RDB快照：Redis DataBase快照方式持久化，将某一时刻的内存数据,以二进制的方式写入磁盘，Redis默认开启
   * 3混合持久化方式：集成两者优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。

3. RDB快照记录的是实际数据，AOF文件记录的是命令操作的日志

4. AOF：以日志的形式来记录每个写操作，只许追加不可以改写，Redis重启会将写指令重新执行一次完成数据的恢复工作；优势：1每修改同步性能差但数据完整性好；2每秒同步；3不同步；   劣势：AOF文件大于RDB文件，恢复速度更慢；运行效率更低

5. RDB：在指定时间间隔将内存中的数据快照写入磁盘，恢复时将快照文件直接读到内存；优势：适合大规模的数据恢复，对数据完整性和一致性不高；劣势：在一定间隔时间做一次备份，如果发生当即会丢失最后一次快照的全部修改

6. 混合方式 优点：使Redis可以更快启动，又降低了大量数据丢失的风险；缺点：实现复杂度高，可读性差，兼容性差

##### Redis集群

1. Redis集群是将原先的单服务器，变为多服务器，保证即使一台出问题还有备份数据，可以保证高可用(啥时候都能用)，数据不丢失

2. 主从同步(复制)模式，哨兵模式，切片机群模式

3. 主从同步：主节点和从节点，和多叉树一样，只有一个主节点，但是能延展出多层的从节点

4. 哨兵模式：主从同步的主节点崩溃后，需要人工干预才能恢复Redis的正常使用；通过哨兵模式(Redis Sentinel)把手动过程变为自动，让Redis拥有自动容灾恢复能力；哨兵对节点进行监视

5. 切片机群模式：Redis Cluster，将数据分布在不同服务区上，降低系统对单主节点的依赖，大大提高Redis服务的读写性能，多个主从节点能够提升性能，具有自动容灾恢复的能力

6. 哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。

   Redis cluster 主要是针对海量数据+高并发+高可用的场景，如果是海量数据，如果你的数据量很大，那么建议就用Redis cluster，所有master的容量总和就是Redis cluster可缓存的数据容量。
   
7. **主从复制**（Master-Slave Replication）：允许一个 Redis 服务器（主节点）将数据复制到一个或多个 Redis 服务器（从节点）。这种方式可以实现读写分离，适合读多写少的场景。

   **哨兵模式**（Sentinel）：用于监控主节点和从节点的状态，实现自动故障转移和系统消息通知。如果主节点发生故障，哨兵可以自动将一个从节点升级为新的主节点，保证系统的可用性。

   **集群模式**（Cluster）：Redis 集群通过分片的方式存储数据，每个节点存储数据的一部分，用户请求可以并行处理。集群模式支持自动分区、故障转移，并且可以在不停机的情况下进行节点增加或删除。

8. 

##### 过期删除与内存淘汰

1. 过期键值删除策略：对设置过期时间的键值进行删除；利用过期字典(expires dict)保存key和过期时间，查询key时，Redis首先检查该key是否存在于过期字典中判断有没有过期
2. Redis使用的过期删除策略是 惰性删除+定期删除，在合理使用CPU时间和避免内存浪费之间取平衡
3. 惰性删除：不主动删除过期间，每次从数据库访问key时，都检查key是否过期，如果过期就删除；
4. 定期删除：每隔一段时间随机从数据库取出一定数量的key进行检查，并删除其中过期key
5. 内存淘汰机制：Redis的运行内存达到某个阈值，就会触发内存淘汰机制，分为在所有数据范围淘汰和在设置过期时间的数据中进行淘汰两类
6. LRU最近久未使用：维护一个访问表，被访问的键会被移动到列表的末端，淘汰时选择列表前面的键
7. LFU最不常使用：基于访问频率的概念，维护一个访问计数器，淘汰访问计数最低的键，Least Frequency Used
8. random随机淘汰任意过期键值；ttl(time to live)优先淘汰更早过期的键值；

##### 缓存异常

1. 缓存异常有四种类型：缓存与数据库的数据不一致，缓存雪崩、缓存击穿、缓存穿透
2. 数据一致性：主要用  1先删除缓存，后更新数据库；2先更新数据库，后删除缓存
3. 怎样保证数据的最终一致性：先更新MySQL，再删除Redis
4. 为什么要删除缓存而不是更新缓存：删除缓存的速度比更新缓存的速度要快得多，等不到更新完下一次请求就又取到未更新值
5. 为什么要先更新数据库，再删除缓存：更新数据库的速度比删除缓存的速度要慢得多，内存操作快于IO操作，先删除缓存会造成数据库还没完成更新，此时读取的数据再写回redis称为脏数据
6. 如何解决删除缓存失败：利用消息队列进行删除的补偿(再次进行删除)，为了避免对业务代码造成大量入侵，可以订阅MySQL数据库的bin log日志对缓存进行操作
7. 缓存雪崩：在缓存中大量的键同时过期或失效，导致请求直接访问存储层，造成存储层宕机
8. 解决方案：1避免同时过期，设置过期时间时附加一个随机数；2构建高可用的Redis缓存；3构建多级缓存；4启用限流和降级措施(请求超出限制时提供降级服务)
9. 缓存击穿：一份热点数据访问量非常大，在其缓存失效瞬间，大量请求直达存储层，导致服务崩溃
10. 解决方案：1加互斥锁，一个线程访问后重新缓存；2永不过期，不设置过期时间或者守护线程加时间
11. 缓存穿透：查询根本不存在的数据，使得请求直达存储层，导致负载过大，设置宕机
12. 解决方案：1缓存空对象，缓存未命中仍存入空值；2布隆过滤器，将所有存在的key提前存入布隆过滤器，访问缓存时通过过滤器拦截，若不存在key则直接返回空值

##### Redis事务

1. Redis 支持简单的事务，可以将多个命令打包，然后一次性的，按照顺序执行

2. 主要通过 multi、exec、discard、watch 等命令来实现：

   - multi：标记一个事务块的开始
   - exec：执行所有事务块内的命令
   - discard：取消事务，放弃执行事务块内的所有命令
   - watch：监视一个或多个 key，如果在事务执行之前这个 key 被其他命令所改动，那么事务将被打断

3. 原理：1使用 MULTI 命令开始一个事务。从这个命令执行之后开始，所有的后续命令都不会立即执行，而是被放入一个队列中。在这个阶段，Redis 只是记录下了这些命令

4. 2使用 EXEC 命令触发事务的执行。一旦执行了 EXEC，之前 MULTI 后队列中的所有命令会被原子地（atomic）执行。这里的“原子”意味着这些命令要么全部执行，要么（在出现错误时）全部不执行

5. 3如果在执行 EXEC 之前决定不执行事务，可以使用 DISCARD 命令来取消事务。这会清空事务队列并退出事务状态

6. 4WATCH 命令用于实现乐观锁。WATCH 命令可以监视一个或多个键，如果在执行事务的过程中（即在执行 MULTI 之后，执行 EXEC 之前），被监视的键被其他命令改变了，那么当执行 EXEC 时，事务将被取消，并且返回一个错误

7. Redis 事务是不支持回滚的，不像 MySQL 的事务一样，要么都执行要么都不执行；一旦 EXEC 命令被调用，所有命令都会被执行，即使有些命令可能执行失败。失败的命令不会影响到其他命令的执行

8. 为什么不支持回滚：引入事务回滚机制会大大增加 Redis 的复杂性，因为需要跟踪事务中每个命令的状态，并在发生错误时逆向执行命令以恢复原始状态。

   Redis 是一个基于内存的数据存储系统，其设计重点是实现高性能。事务回滚需要额外的资源和时间来管理和执行，这与 Redis 的设计目标相违背。因此，Redis 选择不支持事务回滚。

##### IO模型

1. 五种IO模型：阻塞IO，非阻塞IO，信号驱动IO(自动通知)，IO多路复用(重点在于多路)，异步IO
2. 以上五种IO模型是基于网络层面上讲的，而BIO, NIO, AIO 的概念是java层面上java.nio包下的，java里面的NIO封装了IO多路复用的机制
3. 用户空间和内核空间；在用户空间和内核空间都有缓冲区；第一步等待内核缓冲区准备数据就绪，第二步，用户缓冲区从内核缓冲区中读取数据；  数据准备和数据拷贝
4. 1阻塞IO：用户进程在等待数据直到数据就绪 和从内核缓冲区copy到用户空间两个阶段都需要等待
5. 2非阻塞IO：等待数据不阻塞，但是会CPU空转(反复调用直到数据就绪，空轮询不断获取数据)，性能并没有得到提高
6. 3信号驱动：内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。缺点：信号太多导致信号队列溢出，频繁信号交互性能页较低
7. 4IO多路复用：文件描述符FD，关联文件，网络模型可以利用一个线程监听多个FD，并在某个FD可读可写时得到通知，避免无效等待，充分利用CPU资源
8. 阶段一：用户进程调用select指定要监听的FD集合，数据就绪则返回readable；阶段二：用户进程找到就绪的socket，调用recfrom读取数据
9. select和pool需要通过遍历FD方式确定哪个数据准备好了，epoll不需要遍历直接知晓
10. select模式存在问题：你监听的FD最大不超过1024；每次select都需要把所有要监听的FD都copy到内核空间；每次都要遍历所有FD来判断就绪状态
11. poll模式：利用链表解决监听FD上限的问题，但依然要遍历所有FD
12. epoll：基于epoll实例中的红黑树保存要监听的FD，增删改查效率都高；每个FD只需要执行一次epoll_ctl添加到红黑树，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间；利用ep_poll_callback机制来监听FD状态，无需遍历所有FD，因此性能不会随监听的FD数量增多而下降
13. epoll实例：红黑树记录监听的FD，链表记录就绪的FD，epoll_ctl监听FD(注册FD)，epoll_wait等待FD就绪(检查链表是否为空)
14. 5异步IO： 不分等待数据和拷贝数据两阶段，直接一步到位，所以都不阻塞-
15. select，poll，epoll 都是 IO 多路复用的机制。I/O 多路复用就是通过一种机制监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就通知程序进行相应的读写操作。但 select，poll，epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。
16. 使用单个进程同时处理多个网络连接IO，他的原理就是select、poll、epoll 不断轮询所负责的所有 socket，当某个socket有数据到达了，就通知用户进程。该模型的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接

##### JAVA的三种IO模型  BIO NIO AIO 

1. 同步/异步：是否会自动通知水烧开了，不需要来回检查水开没开；阻塞/非阻塞：是否需要原地等待；BIO NIO AIO  都是Java中用于处理I/O操作的不同编程模型
2. BIO(Blocking IO) 同步阻塞：数据的读写必须阻塞在一个线程内等待完成，一个线程处理一个连接
3. NIO(Non)同步非阻塞：一个线程对应一个selector多个channel，面向缓冲区，基于事件驱动
4. AIO(Asynchronous IO)异步非阻塞：基于事件和回调机制实现，
5. 阻塞 I/O（BIO）：BIO是传统的阻塞式I/O模型，它基于流（Stream）和阻塞调用，即当一个线程执行I/O操作时，会阻塞等待数据的到达或操作完成。在这种模型中，一个线程只能处理一个客户端连接，如果有大量的客户端连接同时到达，就需要创建大量的线程来处理，会导致资源消耗和线程切换的开销。
6. 非阻塞 I/O（NIO）：NIO是一种基于事件驱动的I/O模型，引入了通道（Channel）和缓冲区（Buffer）的概念。在NIO中，应用程序通过选择器（Selector）注册对I/O事件的关注，当有事件发生时，通过事件驱动的方式进行处理。NIO提供了非阻塞的I/O操作，可以同时处理多个连接，使用较少的线程来处理更多的客户端请求，从而提高了系统的并发性能。
7. 异步 I/O（AIO）：AIO是一种基于回调机制的异步I/O模型，IO操作由操作系统完成，也称为NIO.2。在AIO中，应用程序发送一个I/O请求后，可以继续执行其他操作，当I/O操作完成时，操作系统会通知应用程序进行后续处理。与NIO不同，AIO的I/O操作由操作系统完成，应用程序无需主动地等待I/O操作的完成。AIO适用于处理需要长时间等待的I/O操作，如网络传输中的大文件传输、数据库读写等。
8. BIO使用基于流的方式进行读写操作，数据直接从输入流或输出流中读取或写入。它没有提供缓冲区的概念，数据是直接从输入流或输出流中传输的；BIO每次只能处理一个连接，当有大量的连接到达时，需要创建大量的线程来处理，容易导致资源消耗和线程切换开销。BIO是Java早期的I/O模型，适用于任何版本的Java。
   NIO使用缓冲区（Buffer）进行读写操作。数据首先被读取到缓冲区中，然后从缓冲区中读取或写入。缓冲区提供了对数据的更灵活的操作，可以进行读写、翻转、压缩、扩展等操作；NIO使用较少的线程来处理更多的连接，通过事件驱动的方式进行处理。一个线程可以同时处理多个连接，在连接之间切换时无需创建新的线程，减少了线程切换开销。NIO是从Java 1.4版本引入的，并在Java 7中进行了一些改进。
   AIO也使用缓冲区进行读写操作，类似于NIO。它提供了与NIO缓冲区类似的操作方法；AIO使用异步的方式进行I/O操作，当一个I/O操作被启动后，应用程序可以继续执行其他操作，不需要等待I/O操作的完成。当I/O操作完成后，操作系统会通知应用程序进行后续处理。AIO是从Java 1.7版本引入的，并在Java 1.7之后的版本中进行了改进。                                                                                                                                                                                                  总体而言，BIO是最传统的I/O模型，适用于连接数较少且并发性要求不高的场景；NIO适用于需要处理大量连接且并发性要求较高的场景，可以提供较高的吞吐量；AIO适用于需要处理大量长时间等待的I/O操作，可以提供更高的并发性能。选择合适的I/O模型取决于具体的应用场景和性能需求。

##### 分布式锁

1. 分布式锁：在多个进程都能访问到的地方，做一个标记，标识该数据的访问权限；同步锁：在多个线程都能访问到的地方
2. 分布式锁特性：1互斥性；2高可用性，一部分服务器宕机不影响正常使用；3防止锁超时，如果客户端没有主动释放锁，服务器回再一段时间自动释放锁，防止死锁；4独占性，加锁解锁由同一台服务器执行，锁的持有者才可以释放锁
3. 实现方式：1基于数据库；2基于Redis；3基于Zookeeper  实现分布式锁
4. Redis实现分布式锁的原则：1安全属性：独享；2活性A：无死锁，即使持有锁的客户端崩溃或者网络被分裂，锁仍然可以被获取；3活性B：容错，只有大部分Redis都活在，客户端就可以获取和释放锁
5. 单Redis实例实现分布式锁：1获取锁使用命令setnx；2使用Lua脚本释放锁
6. v1版本：setnx  + del : 逻辑执行到中间出现异常，del没有被执行导致死锁；  v2版本 : 多加expire，两条指令非原子指令，会在setnx和expire之间挂掉造成死锁；  v3版本：set lock:fighter true ex 5 nx  保证原子性
7. 多Redis实例实现分布式锁：Redlock(Redis Distributed Lock)算法；有现成的实现，java库位Redisson
   1. 获取当前时间戳
   2. 依次获取N个实例，使用相同的key和随机值获取锁，并设置超时响应时间；如果服务器没有在规定时间响应，客户端应该尽快尝试另一个Redis实例
   3. 客户端使用当前时间减去开始获取锁的时间，得到获取锁使用的时间。当且仅当大多数Redis节点都取到了锁，并且使用的时间小于锁失效的时间，锁才算获取成功
   4. 如果取到了锁，key的真正有效时间等于有效时间减去获取锁使用的时间
   5. 如果获取锁失败，客户端应该在所有的Redis实例上进行解锁
8. 



##### 操作命令

1. String：SET, GET, SETEX key seconds value, SETNX key value 
2. Hash:    HSET key field value,  HDEL key field,  HEKYS key,  HVALS key
3. List(栈命令)： LPUSH key value,  LRANGE key start stop,  RPOP key,  RLEN key
4. set(集合命令):   SADD key member,   SREM,  smembers key,  scard key(成员数),  sinter,  sunion
5. zset:      ZADD key score member,  ZREM,  ZRANGE,  ZINCRBY key increment member
6. KEYS pattern,  EXISTS key,  TYPE key,  DEL key



1. String的value可以是字符串，数字，二进制；使用场景：缓存功能，计数(点赞数)，共享Session，限速
2. Hash，使用场景：缓存用户信息，缓存对象
3. List，使用场景：消息队列，文章列表
4. Set，使用场景：共同关注，标签
5. ZSet，用户点赞统计，用户排序，延时队列
6. ZSet的底层原理：listpack(取代ziplist)，调表skiplist；
7. 跳表（skiplist）是一种有序的数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。
8. listpack 是 Redis 用来替代压缩列表（ziplist）的一种内存更加紧凑的数据结构。为了避免 ziplist 引起的连锁更新问题，listpack 中的元素不再像 ziplist 那样，保存其前一个元素的长度，而是保存当前元素的编码类型、数据，以及编码类型和数据的长度。





1. Redis天然可以作为一个分布式系统来使用，因此使用Redis实现的锁都是分布式锁，java的锁是单机
2. 分布式锁是分布式项目开发中用到的锁，可以用来控制分布式系统之间同步访问共享资源；在整个系统提供一个全局、唯一的获取锁的东西，使得锁是同一把锁；东西可以是Redis, Zookeeper，数据库
3. 分布式锁需要满足：1互斥性；2高可用性；3防止锁超时；4独占性
4. Redis实现分布式锁：1加锁，使用setnx(set if not exists)来加锁 setnx key key_name；2解锁，del key；3锁超时，expire key time
5. 上述分布式锁存在问题：1setnx和expire非原子性，中途节点挂了来不及设置过期时间 使用set nx ex过期时间；2锁误解除，A释放了下一个B的锁，判断当前锁是否是自己加的锁，lua脚本；3超时解锁导致并发；4不可重入，Redis可通过对锁进行重入计数，归零释放锁；5无法等待锁释放，轮询或者发布订阅功能

   





