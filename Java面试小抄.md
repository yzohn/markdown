### Java面试小抄

#### java概述

1. java语言特点：面向对象，平台无关性，编译和解释并存，可靠性安全性，支持多线程，支持网络编程
2. 与C++的关系区别：都是面向对象，C支持指针，支持多继承，无自动内存回收操作
3. JDK, JRE, JVM的关系：JRE多加了核心类库和Java命令   JDK多加了开发工具和编译器(javac)
4. 字节码：JVM以字节(两个16进制)为单位读取，字节码由16进制组成；保留了解释型语言可移值的特点，同时解决执行效率低的问题

#### 基础语法

1. 基本数据类型和引用数据类型
2. switch不能作用在long上
3. private，default(不同包不可以)，protected(不同包的子类可以，且只能在子类中调用)，public
4. static关键字：只与类有关，无需创建对象
5. 代码块执行顺序：静态代码块，构造代码块，构造函数，普通代码块
6. 面向对象：易维护，易复用，易扩展，性能比面向过程低
7. 多态：继承，重写，向上转型； 分为编译时(重载)和运行时多态(重写)；  重载必须有一个独一无二的参数类型列表
8. 构造器只能被重载，子类不会覆盖父类的构造函数，相反一开始执行父类的无参构造方法
9. 抽象类和接口：设计层面上区别：一个是对类抽象，模板式设计，一个是对行为抽象，辐射式设计
10. 接口方法public abstract，变量public static final， jdk8后可以有default和static方法，且都有方法体；接口没有构造方法，接口和接口多继承，类和接口多实现
11. java创建对象的方式：new,  反射，序列化机制，clone
12. 不可变对象(String，Integer及其他包装类)  好处：线程安全
13. == 基本数据类型：值    对象：地址值；   equals  对象是否相等
14. hashCode()作用是获取哈希码，以确定该对象在哈希表中的索引位置
15. HashSet先检查hashCode是否相等，如果相等再检查equals，不同的话会散列到其他位置
16. String为什么设计为不可变：1.便于实现字符串池  2.使多线程安全  3.避免安全问题(url, 文件路径) 4.加快字符串处理速度(保证了hashcode唯一性，创建对象时可以放心缓存)
17. HashMap通过key的hashcode来确定value的存储位置，字符串是不变的，因此其hashcode被缓存下来不需要再次计算，相比于其他对象更快
18. 两个通过new出来的Integer变量永远是不相等的(new出来的是两个对象，内存地址不同)
19. 非new出来的Integer变量指向的是常量池的对象，值在(-128,127)比较结果为true
20. 反射是指在运行状态中，对于任意类/对象，都能知道/调用全部方法和属性；动态获取信息和调用对象；缺点：灵活性较低，需要解析字节码文件，将内存中的对象进行解析
21. 反射获取方法：Class.forName   String.class  instance.getClass
22. 反射两个经典实例：jdbc驱动；Spring通过XML配置模式装载Bean
23. 泛型原理：类型擦除(编译器在编译的时候去掉类型参数，除了extends和super都以Object进行替换)，产生的字节码不包括泛型，对包含泛型的方法会进行安全检测，对泛型返回值编译器会插入指令进行强制类型转换(泛型翻译)
24. 泛型的好处：1编译器类型安全(如果插入了其他类型的元素，在编译的时候就会报错，而不是等到运行时才抛出异常)；2避免了强制类型转换运行时异常；3同一个类可以操作多种类型数据，代码复用
25. 泛型的本质就是把类型参数化，所操作的数据类型被指定为参数，根据动态传入进行处理
26. 类型擦除的意思是指：泛型只在编译时起作用，运行时都当作object处理；由于类型擦除，所以当泛型方法被调用后编译器会额外插入一行指令用于强制类型转换，叫做泛型翻译
27. 不同泛型差异体现在类编译的时候，当JVM进行类编译时会进行泛型检查(new ArrayList\<String>  和new ArrayList\<Integer>的Class类型是一致的，都是ArrayList.class)
28. 序列化：把Java对象转换成有序字节流，作用：对内存中的对象进行持久化或网络传输
29. 序列化实现方法：Serializable接口，Externalizable接口(需实现接口内两个方法，自己决定存储什么信息，性能略好)  transient阻止字段序列化
30. serialVersionUID 用来表明类的不同版本间的兼容性;在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。
31. serialVersionUID 需要显式指定，否则在序列化和反序列化都会自动生成一个，只有显式指定了才能保证一致，不显式指定 一旦类改变了，旧对象反序列化就会失败
32. 序列化针对的是对象而非类，静态变量不会被加载
33. Errors和Exception都继承自Throwable；Exception是指程序本身可以处理的异常，可以用catch捕获，分为运行时和非运行时，区别：是否强制要求调用者处理
34. 非运行时异常：IO, SQL, ClassNotFound   运行时异常：空指针，indexOutofBounds,计算异常  error:堆栈溢出，虚拟机， outofMemory
35. 非受检查异常指的是运行时异常，受检查异常是出运行时异常外的所有异常，我们需要把编译时异常转化为运行时异常
36. throw用在方法内部，只能用于抛出一种异常； throws用在方法声明上，可以抛出多种异常
37. JVM如何处理异常：方法创建异常对象并转交JVM后，JVM会顺着调用栈去查找是否有处理异常的代码，如果有就将发送的异常传递给它，没有的话就将异常转交给默认的异常处理器，打印出异常信息并终止应用程序
38. try-catch-finally中 catch可以省略，try只适合处理运行时异常，try-catch适合处理运行时异常+普通异常；编译器硬性规定：普通异常如果选择捕获，必须用catch显式声明以便进一步处理   (把编译时异常转换成运行时异常)

#### IO

1. IO流分为几种：按照流的方向：输入和输出；实现功能：结点流和处理流(对已存在流进行封装, BufferedReader)；处理数据单位：字符流和字节流
2. FileInputStream, 一次读取一个字节；InputStreamReader,一次读取一个字符；BufferedReader一次读取一个行readLine
3. IO有哪些设计模式：适配器(InputStream +Reader) 把一个类的接口变换为期望的另一种接口； 装饰器：动态往一个类中添加新的行为的设计模式

#### JAVA集合

1. 学过的集合都是线程不安全的，线程安全的Stack, Vector, Hashtable
2. ArrayList和LinkedList异同点：都不线程安全，Object数组/双向链表，插入和删除受元素位置影响，支持快速随机访问get，内存空间占用大小
3. ArrayList和Vector区别：线程安全(Vector在关键方法前面都加了synchronized)，ArrayList在底层数组不够时扩展0.5倍，Vector扩展1倍，ArrayList有利于节约内存空间
4. ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。默认情况下，新的容量会是原容量的1.5倍
5. Array和ArrayList区别：包含类型范围不同(基本+对象)； 大小是否固定； 提供了方法
6. HashMap底层数据结构：数组+链表+红黑树(1.8新加)；链表在一定条件下会转换为红黑树：当链表超过8并且数据总量超过64；转换前会判断 如果数组容量小于64，会进行数组扩容而非转换为红黑树
7. 解决hash冲突的方法：开放定址法(嵌套hash函数计算)，再哈希法(多个hash函数)，链地址法(单链表，hashmap采用，采用链表的头插入方式)，建立公共溢出区
8. 为什么先用链表再转红黑树：红黑树需要变色左旋右旋来保持平衡，单链表不需要，当元素小于8时，链表结构能够保证查询性能，大于8时，链表搜索复杂度O(n)，红黑树O(logn)；一开始就使用红黑树，新增效率比较慢，浪费性能
9. HashMap默认加载因子0.75，是对空间和时间效率的一个平衡选择，扩容成两倍(还需要rehash), 扩容是为了减少哈希碰撞
10. HashMap中key的存储索引如何计算：三步，取key的hashCode值，根据hashcode计算出hash值hash=h^(h>>>16)，通过取模计算下标(位运算)  hash&（length-1）
11. HashMap扩容，创建出一个新的数组，容量为之前的两倍，讲键值对放到新计算出来的索引位置上，一部分索引不变，一部分索引为  原索引+旧容量
12. HashMap为什么线程不安全：多线程下扩容死循环(环形链表)，多线程的put可能导致元素的丢失，put和get并发时 可能导致get为null(扩容rehash时)
13. ConcurrentHashMap(都是jdk1.8) 实现原理：也是数组+链表+红黑树，锁的实现上采用CAS+Synchronized实现了更加低粒度的锁(哈希桶元素级别)，锁住的是链表头节点(红黑树根节点)，不影响其他桶的读写，提高了并发性
14. put步骤：1计算hash  2判断是否需要初始化  3定位Node拿到首节点，判断  1)为null用CAS方式添加；  2)hash=MOVED=-1 说明其他线程在扩容，一起参与扩容；3)都不满足，加Synchronized锁，遍历插入；  4 链表长度达到8时扩容数组或转换红黑树
15. get不加锁，Node元素val和指针用volatile修饰，线程A修改的val对线程B可见
16. 哈希桶用volatile修饰是为了保证在数组扩容时的可见性
17. ConcurrentHashMap不支持key/value为null，多线程map.get(key)得到null，无法判断是映射的value是null还是key为null，HashMap可以用containsKey(key)判断
18. ConcurrentHashMap比Hashtable效率高，因为锁的细粒度更低CAS+Synchronized, Hashtable是直接给哈希表加了一把大锁
19. HashSet使用对象来计算hashcode(equals)，所以比使用唯一的键获取对象的HashMap慢
20. HashSet的底层其实就是HashMap，只不过我们HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存
21. 