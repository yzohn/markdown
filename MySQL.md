### MySQL

#### 基础篇

1. 流程函数：if(value,t,f),   ifnull(value1, value2)   case when … then  else … end

2. 日期函数：curdate(),   curtime(),  now(),  data_add(date, INTERVAL 10 month),  datediff()相减 

3. ```
   (case when age > 30 then '中年' else '青年' end)
   ```

4. 自连接查询：select a.name, b.name from employee a, employee b where a.manager = b.id;

5. select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx');

6. 事务的四大特性：原子性，一致性(转账和接收要么同时成功要么同时失败)，隔离性(不受并发操作影响)，持久性

7. 并发事务：脏读(一个事务读取到另一个事务还没提交的数据)；不可重复读(先后读取的同一条记录数据不同)；幻读

8. 并发事务隔离级别：从低到高: Read uncommitted,  Read committed,  Repeatable Read(默认),  Serizlizable;   (读未提交，读提交，可重复读，串行化)依次解决脏读，不可重复读，幻读

#### 进阶篇

目录：存储引擎，索引，SQL优化，视图/存储过程/触发器，锁，InnoDB引擎，MySQL管理

1. MySQL分为Server层和存储引擎层
2. Server层包括：连接器，查询缓存(命中率低，只要有一个表更新，缓存全部清除)，分析器，优化器，执行器
3. 体系结构：Mysql Server包括：连接层，服务层，引擎层，存储层
4. 存储引擎：InnoDB  特点：支持事务；行级锁，提高并发访问性能；支持外键约束
5. MyISAM mysql早期默认存储引擎  特点：不支持事务，不支持外键，支持表锁，不支持行锁
6. Memory 特点：存放在内存中，速度快，hash索引(默认)



1. 索引是帮助MySQL高效获取数据的数据结构(有序)；优点：提高数据检索效率，通过索引对数据进行排序；缺点：索引列要占空间，提高了查询效率但降低了更新的速度
2. 二叉树顺序插入时会形成一个链表(不平衡)；大数据量情况下，层级较深，检索速度慢
3. B-Tree多路平衡查找树：5阶，每个结点最多存储4个key和5个指针
4. B+Tree：所有的数据都出现在叶子结点，叶子结点形成一个单向链表(MySQL改为了双向链表)
5. Hash：只能用于对等比较(=,in)，不支持范围查询；无法利用索引完成排序操作，查询效率高，通常只需要一次索引(直接计算hash值)
6. InnoDB为什么选择B+Tree：1相比二叉树，层级更少，搜索效率更高；2相比于B-Tree，无论叶子or非叶子结点都会保存数据，导致一页中存储的键值减少，指针也要减少，要保存大量数据只能增加树的高度，导致性能变低；3相比Hash索引，支持范围匹配及排序操作
7. 说明：页包括键值，数据，指针；B+Tree非叶子节点只包含键值不存放数据，能存放更多指针
8. InnoDB中，根据索引的存储形式，可以分为：聚集索引和非聚集索引
9. 聚集索引一般以主键为排序方式，叶子节点保存了数据所有信息，必须存在且只有一个；二级索引以其他键为排序方式，叶子节点仅保存主键；
10. 因此根据非主键查找数据时，首先根据二级索引找到主键，再由主键查询到全部数据；称为回表查询
11. 索引使用规则：最左前缀法则：如果是联合索引(关联了多个字段)，需要遵循最左前缀法则，从该联合索引的最左列开始(和sql语句的顺序无关)，并且不跳过索引中的列；如果跳跃了某一列，后面的字段索引会失效；如果出现范围查询，范围查询右侧的列索引失效，可以用>=来规避索引失效问题;因为创建联合索引时是先排最左边的(先按name排序，再age，跳过name查age不可行)
12. 索引失效的情况：1索引列上进行运算操作，如substring; 2字符串不加引号‘ ’；3模糊查询  前面加%会失效，后面加%不会失效；4用or时任意一个条件的列没有索引；5如果MySQL评估使用索引会比全表查询慢，则不使用索引
13. SQL提示：建议使用索引 use index(idx)    不使用 ignore index(idx)  必须使用 force index(idx)
14. 优化select id, username, password from tb_user where username='itcast';  建立一个username和password的联合索引；当要查找的信息在二级索引里都有时，就不用再回表查询了；索引覆盖
15. 前缀索引：只针对字符串前面几个字符创建索引  create index idx  on table_name(columnn(n))
16. 建议建立联合索引而非单列索引(覆盖索引)，可以避免回表查询； 多条件联合查询时，MySQL优化器会自动评估哪个索引效率高



1. sql优化：普通插入：采用批量插入，手动提交事务，主键顺序插入；大批量插入：load指令
2. 主键优化：为了保证主键的顺序排列，会产生页分裂和页合并；主键设计原则：1尽量短2顺序插入，自增；3避免对主键的修改(都是自动生成不修改的)；4不适用uuid或身份证号
3. Using filesort，先获取数据再在缓冲区完成排序；  Using index直接根据索引有序返回数据；联合索引同时升序或降序才会走索引，否则需要在创建联合索引时制定升序降序
4. count优化；MyISAM引擎将总数存在磁盘上，InnoDB没有，所以count(\*)是手动累计计数；优化方案：自己计数key-value或redis；效率：count(*)>=count(1)>count(主键)>count(字段)；检查是否为null<返回字段<不返回字段
5. update优化(避免行锁升级为表锁)：InnoDB是根据索引加的锁，查询时如果有索引字段就加行锁，否则就从行锁升级为表锁



1. 视图(view):虚拟存在的表，不保存查询结果，只保存查询的SQL逻辑，简单，完全，数据独立

2. 存储过程(procedure):函数，减少网络交互，提高性能，封装重用，变量, if, case, 参数(in/out/inout), while, repeat, loop, cursor, handler

3. 存储过程(function):有返回值的存储过程，参数类型只能为int类型，可以被存储过程替代

4. 触发器(trigger):可以在表数据进行insert, update, delete之前或之后触发，保证数据完整性，日志记录，数据校验

5. 视图：create view name as select \* from dept;   select \* from view_name;  alter

6. 存储过程：一段sql语句，函数；create procedure name() begin end; 调用call procedure_name() 有比较多语法；游标(cursor)用来存储查询结果集；declare name cursor for select…;  open cursor_name;  fetch cursor_name into 变量；

   

1. 锁：全局锁，表级锁，行级锁；  全局锁加锁后都处于只读状态

2. 表级锁：分为三类：表锁，元数据锁，意向锁

3. 表锁：分为读锁(只能读不能写，当前加锁的也是)和写锁；      元数据锁：系统自动控制，维护数据一致性，增删改查加读锁(共享)，表结构变更加写锁(排他)；    意向锁：避免行锁和表锁冲突，客户端对某一行加了行锁后，系统自动加上意向锁(不用对表中每行检查是否加锁)，其他客户端再加表锁时会检查意向锁是否加锁(共享兼容共享)

4. 行级锁：对索引上的索引项加锁实现，分为三类：行锁，间隙锁，临键锁(行锁+间隙锁)

5. 行锁：分为共享锁和排他锁: 增删改加排他锁，查不加锁，共享锁只能显式要求；

   

12. InnoDB引擎：逻辑存储结构：分为表空间，段(数据段，索引段，回滚段，对应就是B+Tree)，区，页，行

13. 架构：分为内存架构和磁盘架构

14. 内存架构：缓冲池Buffer Pool,  更改缓冲区Change Buffer,  Log Buffer,  Adaptive Hash index

15. 缓冲池：执行增删改查时先操作缓存池的数据，再以一定概率刷新到磁盘，以页为单位，数据修改过的页称为脏页

16. 更改缓冲区：对于非唯一二级索引页，更改数据时再Change Buffer，再数据被读取时合并到缓冲池

17. 自适应哈希：系统自动完成，系统自动检测是否哈希索引可以提升速度，再建立hash索引

18. 日志缓冲区：保存redo log, undo log，定期刷新到磁盘

19. 磁盘架构：

20. 后台线程：负责在合适的时机将内存缓存刷新到磁盘

21. 事务管理：如何保证原子性，一致性，持久性， 隔离性

22. 原子性：undo log;        持久性：redo log;      一致性：undo+redo;        隔离性：锁+MVCC

23. redo log记录事务提交时对数据页的物理修改，分为重做日志缓冲和重做日志文件，分别在内存和磁盘；事务提交后，先提交log到磁盘，完成脏页刷新后再检查是否发生错误，进行数据恢复使用

24. undo log回滚日志：记录数据的历史版本，用于回滚，用段管理和记录

25. 当前读：读取的是记录的最新版本，需要加锁保证其他并发事务不修改当前记录(增删改都是)；快照读：读取的是可见版本，可能是历史数据，不加锁(普通查是)

26. MVCC多版本并发控制：维护一个数据的多个版本，使得读写操作没有冲突，具体实现：数据库记录的三个隐式字段，undo log日志，readView

27. MVCC隐式字段：DB_TRX_ID 最近修改事务ID,  DB_ROLL_PTR回滚指针，指向这条记录的上一个版本，DB_ROW_ID隐藏主键，没有指定主键时生成

28. undo log版本链：链表头部是最新的旧记录，尾部是最早的旧记录，记录的就是更改前数据

29. Readview用于快照读，记录并维护系统当前活跃的事务(未提交)id；沿着undo log版本链对照访问规则选择符合规则的记录

30. ReadView包含：创建该视图的事务id(自增)，创建该视图时所有活跃事务的事务id(m_ids)，m_uds最小的事务id, 下一个创建ReadView的事务的事务id

31. 可重复读：每一个事务都会创建一个ReadView，当发现两个隐藏字段(最近修改的事务id)比自己大，并且在自己记录的当前活跃事务id列表中，并且还比下一个事务id小，因此认为期间由其他事务修改了当前数据，于是通过两个隐藏字段(回滚指针)找到最近修改id比自己小，并且不在活跃的事务id中的第一条记录，实现可重复读

32. 读提交和可重复读的区别：在于它们生成ReadView的策略不同，读已提交每次查询时都会生成一个新的ReadView，而可重复读每次查询都复用第一次生成的ReadView，然后分别按照ReadView的访问规则最终实现读已提交和可重复读

33. 串行化强制要求事务排序，事务在读操作时，必须先加表级共享锁，知道事务结束才释放；在写操作时，必须先加表级排他锁，知道事务结束才释放

34. 1若某事务试图去访问id为10对应的版本数据，它比列表中最小的事务id20还要小，说明它在很早之前就提交了，那么这个id为10的事务对应的版本数据是可以访问的。
    2若某事务试图去访问id为30对应的版本数据，它大小介于列表中活跃事务id之间，此时就要判断它是否在列表中，若在，则说明还未提交不能访问，若不在，则说明已经提交可以访问。
    3若某事务试图去访问id为50对应的版本数据，它比列表中最大的事务id40还大，说明它是在生成ReadView之后才发生的，可能还没提交，所以不能访问。

#### 面试小抄

1. 一条SQL查询语句是如何执行的：MySQL逻辑架构图(Server层，还有存储引擎)

2. 1连接器(负责连接，权限验证)；2查询缓存；3分析器(语法/词法分析，知道要做什么)；4优化器(执行计划生成，索引选择，知道要怎么做)；5执行器(操作引擎，返回结果)

3. 事务隔离级别：读未提交，读提交，可重复读，串行化，依次解决 脏读，不可重复读，幻读

4. 读提交(大部分数据库默认)，可重复读(MySQL默认)，串行化(通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上表级共享锁，写加上表级排他锁，直到事务结束才释放。在这个级别，可能导致大量的超时现象和锁竞争)

5. 1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据

   2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。

   3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

   不可重复读侧重于修改，幻读侧重于新增或删除（多了或少量行），脏读是一个事务回滚影响另外一个事务。

6. 可重复读的实现原理：MVCC，

7. 事务的四大特性：原子性，一致性，隔离性(多个并发事务执行互不干扰)，持久性

8. 索引数据结构：B+树索引，哈希索引，全文索引；  物理存储维度分类：聚集索引，非聚集索引

9. 什么时候需要索引：1主键；2经常条件查询where的字段；3与其他表关联的字段如外键；4排序的字段；6unique；7大表中的关键列

10. 不需要创建索引的情况：1小表；2频繁的插入删除更新操作；3数据重复且平均的表字段；4很少被查询的字段；5查询结果总行数较少的表

11. 索引失效：1  !=或者><；2 类型不一致；3 索引列使用函数/运算符；4 OR；5 模糊索引；6Not in/exists

12. 非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键

13. 使用自增长主键作为索引，能够减少页分裂和移动的频率

14. Redo log记录的是物理日志(在某个表做了什么修改)，记录完成写上Commit Record，持久化完成写上End Record；Undo log记录的是回滚信息，备份事务执行前的旧值；Bin log记录的是sql语句

15. bin log是server层记录的，用作数据备份主从复制，是逻辑日志 记录的是sql语句，写满新增接着写；redo log是存储引擎层产生的，用作持久化，是物理日志，循环使用

16. MVCC多版本并发控制：维护一个数据的多个版本，使得读写操作没有冲突

17. 核心思想：每个事务在数据库看到的数据版本是事务开始时的一个快照(区别于当前读)，而不是实际的最新版本，使得多个事务可以并发执行，不会互相干扰

18. 实现：1表的三个隐式字段：DB_TRX_ID 最近修改事务ID,  DB_ROLL_PTR回滚指针，指向这条记录的上一个版本，DB_ROW_ID隐藏主键，没有指定主键时生成; 2undo log版本链，回滚指针指向的历史版本存放在undo log里；3查询数据时会构造一个ReadView，记录并维护系统当前活跃的事务(未提交)id；沿着undo log版本链对照访问规则选择符合规则的记录

19. InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。

20. 执行引擎：InnoDB：提供事务，行级锁，外键约束；MyISAM：只有表锁，不提供事务和外键约束；Memory：数据放在内存中，数据处理快，默认哈希索引，安全性不高

21. MySQL日志文件：1undo log；2redo log；3binlog归档日志，Server层生成的日志，用于数据备份和主从复制；4relay lof中继日志，用于主从复制场景下，slave通过io线程拷贝master的bin log后本地生成的日志

22. 全局锁：用于全库逻辑备份，也就是备份数据库

23. 表级锁：开销小，加锁快，发生锁冲突的概率高，并发度低，不会产生死锁，行级锁相反

24. 表级锁：表锁(读锁和写锁)，元数据锁(CRUD时系统自动加上，防止其他线程变更数据)；意向锁(加行锁时自动加上，判断共享还是独占)

25. 表锁(读锁写锁，避免使用，颗粒度太大影响并发性能)，元数据锁(读锁写锁，自动加，事务提交后才会释放)，意向锁(共享/独占，目的是为了快速判断表里是否有记录被加锁，只会和共享表锁和独占表锁发生冲突，加共享/独占表锁时可以不用遍历所有记录查看是否存在，直接查看意向锁就行)

26. 行锁又分为共享锁S，排他锁X，普通select不加锁为快照读，显式增 删改查加S/X锁，为当前读；两阶段锁协议：行锁是需要时加上，但是要事务结束时才释放；

27. 行锁是基于索引实现的，(基于读提交隔离级别)没有索引的情况下，InnoDB的当前读会对所有记录都加锁(严重影响业务)；有索引，就会在索引以及对应的聚集索引上加X锁

28. 间隙锁：指对一个索引范围中的“空隙”进行锁定，防止其他事务在这个范围内插入新数据。间隙锁用于解决幻读问题，例如在某个事务中执行了一个范围查询，然后在范围内的间隙处插入了新数据，这时再次执行相同的查询，会发现有一些行出现了两次，这就是幻读。通过间隙锁，可以防止其他事务插入新的数据，从而避免幻读。一是为了防止幻读，二是为了满足恢复和复制的需要

29. 死锁的场景：事务一先更新数据1后更新2，事务二先更新2后更新1；

30. 解决方案：1一般InnoDb会自动检测到，并使一个事务回滚另一个事务继续；2设置超时等待时间

31. 避免死锁：1如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会

    2、以批量的方式处理数据时，应事先对数据排序，保证线程按固定的顺序来处理数据

    3、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

    4、在事务中，如果要更新记录，应该申请足够级别的锁，即排他锁

32. 分库分表：是为了解决单库单表数据量过大导致数据库性能下降的一种解决方案，分库策略有两种

    1. 垂直分库：按照业务模块将不同的表拆分到不同的库中，如用户表，订单表
    2. 水平分库：按照一定的策略将一个表中的数据拆分到多个库中，如用户id的hash值高低

33. 当表单数据增量过快，超过500万的数据量就要考虑分表，也包括垂直拆分和水平拆分；垂直拆分如拆分文章表和详情表，减轻只查询文章基本数据的查询压力

34. SQL优化：1避免不必要的列(select \*)；2分页优化；3索引优化；4JOIN优化；5排序优化；6UNION优化

35. 索引优化：1使用覆盖索引；2避免使用!=或者<>操作符；3适当使用前缀索引；4避免列上使用函数；5正确使用联合索引(最左前缀法则)；(就是避免索引失效的情况)

36. JOIN优化：1优化子查询(join代替子查询，子查询相当于查两次)；2小表驱动大表(A left join B，A表小于B表，建立连接的次数少，查询速度快)；3适当增加冗余字段，来避免join操作；4避免使用join关联太多表(不超过3个)

37. 排序优化：利用索引扫描做排序(select name order by name)





1. 主从同步、读写分离
2. MYSQL优化
3. 











