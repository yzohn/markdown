#### Kafka

1. Kafka是一个分布式流处理平台，用于实时构建流处理应用，核心功能作为企业级的消息引擎被广泛使用
2. 术语：Broker：Kafka的服务器； Zookeeper：管理集群； Topic：发布订阅模式，生产者把消息发布到的空间就叫topic(区别于点对点模式每个消费者拿到的消息都不同)； Partition：是对Topic位置的分区；Offset：消息在分区中的索引； Leader Replica：主副本，可以处理请求   Follower Replica：从副本，只用作备份
3. Kafka将消息以topic为单位进行归纳，向kafka topic发布消息的程序称为producers，将预定topics并消费消息的程序称为consumer；kafka以集群的方式运行，可以有一个或多个服务组成，每个服务叫做一个broker，producers通过网路将消息发到kafka集群，集群向消费者提供消息
4. 如何保证高可用：基本架构组成是：由多个broker组成一个集群，每个broker是一个节点，当创建一个topic时会被划分为多个partition，每个partition可以存在于多个broker上，每个partition只存放一部分数据；这是天然的分布式消息队列，一个topic的数据，是分散再多个机器上的，每个机器就放一部分数据；Kafka0.8提供了replica副本机制，每个partition上的数据都会被同步到其他机器，形成自己的replica副本，所有replica会选举一个leader出来，消息的生产者和消费者都和leader打交道，其他replica作为follower，写的时候leader会复制把数据同步到所有follower上，读的时候就直接读leader上的数据。Kafka复制均匀的将一个partition的所有replica分布在不同的机器上，这样才能提高容错性；
5. 基于replica副本机制，如果某个broker宕机了，其所在的partition在其他机器上还有副本，如果该broker有leader，则会重其Follower中重新选举新的leader出来，继续提供读写服务，达到所谓的高可用性；
6. 写数据时，只有leader受到所有follower的ack之后，才会返回写成功的消息给生产者，此时消费者才能读到数据
7. 生产者使用push模式将消息发布到Broker，消费者使用pull模式从Broker订阅消息；push速度太快，容易造成消费者拒绝服务或网络拥塞，速度太慢容易造成消费者性能浪费；pull当Broker没有消息时会陷入不断轮询中，为了避免这点，有个参数可以让消费者阻塞知道是否有新消息到达
8. 与传统消息系统之间的区别：1持久化日志，可以被重复读取和无限期保留；2分布式系统：它以集群的方式运行，可以灵活伸缩，在内部通过复制数据提升容错能力和高可用性；3支持实时的流式处理
9. 消费者组：是Kafaka独有的概念，是Kafka提供的可扩展且具有容错性的消费者机制；消费者组（Consumer Group）其实包含两个概念，作为队列，消费者组允许你分割数据处理到一组进程集合上（即一个消费者组中可以包含多个消费者进程，他们共同消费该topic的数据），这有助于你的消费能力的动态调整；作为发布-订阅模型（publish-subscribe），Kafka允许你将同一份消息广播到多个消费者组里，以此来丰富多种数据使用场景。
10. Kafka使用ZooKeeper存放集群元数据、成员管理、Controller选举，以及其他一些管理类任务
11. offset的作用：在Kafka中，每个主题分区下的每条消息都被赋予了一个唯一的ID数值，用于标识它在分区中的位置。这个ID数值，就被称为位移，或者叫偏移量。一旦消息被写入到分区日志，它的位移值将不能被修改。
12. kafka producer发送数据，ack为0, 1, -1分别为什么意思：1：默认，只需要leader确认接收消息就认为发送成功，如果leader宕机会丢失数据；   0：发出去就不管了，不需要等待任何返回，传输效率最高，数据可靠性最低；  -1：可靠性最高，需要等待所有replica向leader发送ack，leader才commit
13. Kafka如何保证消息不丢失：生产者、MQ、消费者三个角色数据处理和传输过程中，都有可能出现消息丢失
    1. 消费者接受到消息，还没来得及处理就宕机了，但MQ认为消息已被处理了：主要原因就是消息还未处理完 Kafka 会自动提交了 offset，那么只要关闭自动提交 offset，消费者在处理完之后手动提交 offset，就可以保证消息不会丢失
    2. 生产者发送消息给Kafka，由于网络等原因导致消息丢失：这种情况也是通过在 生产者producer 端设置 acks=all 来处理，这个参数是要求 leader 接收到消息后，需要等到所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试
    3. Kafka导致的消息丢失，某个Broker宕机，而这个节点正好是某个partition的leader节点，这时需要重新选举该partition的leader。如果该 partition 的 leader 在宕机时刚好还有些数据没有同步到 follower，此时 leader 挂了，在选举某个 follower 成 leader 之后，就会丢失一部分数据：设置4个参数，来尽量避免消息丢失
14. Kafka如何保证消息的顺序性：在某些业务场景下，需要保证对于有逻辑关联的多条MQ被按顺序处理；需要考虑两点：1如何保证消息在Kafka中顺序性；2如何保证消费者处理消费的顺序性
15. 如何保证消息在Kafka中顺序性：对于 Kafka，如果我们创建了一个 topic，默认有三个 partition。生产者在写数据的时候，可以指定一个 key，比如在订单 topic 中我们可以指定订单 id 作为 key，那么相同订单 id 的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。消费者从 partition 中取出来数据的时候，也一定是有顺序的。通过制定 key 的方式首先可以保证在 kafka 内部消息是有序的。
16. 如何保证消费者处理消费的顺序性：对于某个 topic 的一个 partition，只能被同组内部的一个 consumer 消费，如果这个 consumer 内部还是单线程处理，那么其实只要保证消息在 MQ 内部是有顺序的就可以保证消费也是有顺序的。但是单线程吞吐量太低，在处理大量 MQ 消息时，我们一般会开启多线程消费机制，那么如何保证消息在多个线程之间是被顺序处理的呢？对于多线程消费我们可以预先设置 N 个内存 Queue，具有相同 key 的数据都放到同一个内存 Queue 中；然后开启 N 个线程，每个线程分别消费一个内存 Queue 的数据即可，这样就能保证顺序性。当然，消息放到内存 Queue 中，有可能还未被处理，consumer 发生宕机，内存 Queue 中的数据会全部丢失，这就转变为上面提到的如何保证消息的可靠传输的问题了。
17. ISR，AR代表什么；ISR(In-Sync Replicas，副本同步队列)，AR(Assigned Replicas，所有副本)
18. Kafka replica副本分为leader, follower，区别是：只有leader才能对外提供读写服务，响应Clients的请求，follower只是采用pull的方式，被动地同步leader副本中的数据，并且在leader副本所在broker宕机后，随时准备应聘leader副本
19. kafka为什么不支持主写从读(读写分离)：生产者写入消息和消费者读取消息都是于leader副本进行交互的，是主写主读的生产消费模型：
    1. 数据一致性问题：数据从主节点转到从节点有一个延时窗口，这个时间会导致主从节点之间的数据不一致。
    2. 延时问题：数据从主节点同步到从节点的过程会比较耗时，对于延时敏感的应用来说，主写从读的功能并不太适用
20. 解耦：生产者消费者模型，生产者只管生产，消费者只管消费消息，实现了解耦；异步：系统将耗时的任务放在消息队列中异步处理，从而快速响应用户的请求；削峰：处理大量请求时，可以起到缓冲的作用，能抗住短时间内大量的流量





#### ElasticSearch

1. ElasticSearch是一个开源的分布式搜索引擎，可以用来实现全文搜索功能，可精确匹配搜索结果，并高亮显示关键词

2. 为什么使用Elasticsearch：论坛的数据很多，如果采用以往的模糊查询，会放弃索引，导致全表查询，在大规模的数据量时查询效率低下，而使用ES做一个全文索引，将经常查询到的帖子的标题、内容放入索引库里，可以提高查询速度(还可以根据时间，分数排序)

3. 术语：索引：table； 文档：数据库的一行数据，数据结构为JSON； 字段：数据库中的一列；集群：分布式部署，提高性能； 节点：集群中的每一台服务器； 分片：对一个索引的进一步划分存储，提高并发处理能力；副本：对分片的备份，提高可用性

4. 正向索引和倒排索引：正向索引：遍历文档找目标词条，逐行扫描也就是全表扫描，随着数据量增加，查询效率也会越来越低；倒排索引：根据词条找文档的过程，从词条对应的文档id找文档

5. 倒排索引的创建流程：1分词，将每一个文档的数据利用算法分词，得到一个个词条；2映射关系表：创建分词和文档id的映射关系表；3词条–>id–>文档：搜索词条时，根据映射关系表找到它对应的所有文档id，然后根据文档id正向所有查到文档

6. 倒排索引的搜索流程：对输入内容进行分词得到词条，拿着词条在倒排索引中查找得到文档id，拿着文档id到正向索引中查找具体文档

7. 优点：根据词条搜索、模糊搜索时速度非常快；缺点：只能根据词条创建索引而非字段，无法根据字段做排序

8. 词条：文档按照语义分成的词语，利用某种算法分词，得到的具备含义的词语就是词条；文档：每一条数据就是一个文档；索引是文档的集合，类似于表

9. ES是面向文档存储的，文档数据可以是一条商品数据或者订单数据，会被序列化为josn格式后存储在ES中

10. Mysql：擅长事务类型操作，可以确保数据的安全和一致性;对安全性要求较高的写操作，使用mysql实现

11. Elasticsearch：擅长海量数据的搜索、分析、计算；对查询性能要求较高的搜索需求，使用elasticsearch实现

12. 分词器作用：创建倒排索引时对文档分词，用户搜索时对输入内容分词；ik_smart:智能切分，粗粒度；ik_max_word：最细切分，细粒度

    

#### Caffeine

1. 怎样保证二级缓冲和Redis缓存的数据一致性：数据发送变化时直接删除Redis中的数据就行；保证本地缓存和Redis缓存的一致性策略：1设置本地缓存的过期时间，当本地缓存过期时，就从Redis缓存中同步数据，最简单最直接；2使用Redis的Pub/Sub机制，当Redis缓存发生变化时，发布一个消息，本地缓存订阅这个消息，然后删除对应的本地缓存；3Redis缓存发生变化时，引入消息队列区更新本地缓存



#### 设计模式

1. 设计模式是软件工程中常用的解决特定问题的模版或者蓝图，可以帮助我们开发者以一种更加清晰、高效和可重用的方式来编写代码。通常分为三类：
   1. **创建型模式**：涉及对象实例化，用于创建对象的模式，可以增加程序的灵活性和可重用性。常见的创建型模式有工厂方法、抽象工厂、单例、建造者、原型等。
   2. **结构型模式**：涉及类和对象的组合，用于设计类和对象的结构，以便更好地实现程序的功能。常见的结构型模式有适配器、桥接、组合、装饰、外观、享元、代理等。
   3. **行为型模式**：用于描述对象之间的通信和责任分配，关注对象之间的通信，包括责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法、访问者等。
2. 单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式主要用于控制对某些共享资源的访问，例如配置管理器、连接池、线程池、日志对象等
3. 工厂模式（Factory Pattern）属于创建型设计模式，主要用于创建对象，而不暴露创建对象的逻辑给客户端。简单工厂只有一个工厂类，通过该类的静态方法根据传入的参数创建不同的对象。 而抽象工厂则有多个工厂类，每个工厂类负责创建一组相关的对象。 简单工厂的产品对象通常属于同一类别，而抽象工厂则可以创建不同类别的产品对象
4. 代理模式：在不改变原有代码的基础上，增加新的功能，包括静态代理，动态代理(JDK动态代理，cglib代理)
5. 模板模式：具体子类重写抽象类的行为方法。AQS基于模板方法进行设计，锁的实现类需要基础AQS并重写它指定的方法
6. 观察者模式：当主题对象状态发生改变时，它的观察者对象都能得到通知并自动更新。行为型设计模式（描述对象之间的通信和责任分配）
7. 策略模式：是一种行为型设计模式，它定义了一系列算法，并将每个算法封装起来，使得它们可以互相替换，就是实现一个接口，以接口的形式对策略实现类进行调用
8. 





#### Spring中的设计模式

1. 工厂模式是一种创建型设计模式，它提供了一种创建对象的方式，使得应用程序可以更加灵活和可维护。在 Spring 中，FactoryBean 就是一个工厂模式的实现，使用它的工厂模式就可以创建出来其他的 Bean 对象。
2. 单例模式是一种创建型设计模式，它保证一个类只有一个实例，并提供了一个全局访问点。在 Spring 中，Bean 默认是单例的，这意味着每个 Bean 只会被创建一次，并且可以在整个应用程序中共享。
3. 代理模式是一种结构型设计模式，它允许开发人员在不修改原有代码的情况下，向应用程序中添加新的功能。在 Spring AOP（面向切面编程）就是使用代理模式的实现，它允许开发人员在方法调用前后执行一些自定义的操作，比如日志记录、性能监控等。
4. 观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，使得当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。Spring 事件驱动模型使用观察者模式，ApplicationEventPublisher 事件发布者将事件发布给 ApplicationEventMulticaster 事件广播器，该广播器将事件派发给 @EventListener 注解的事件监听者。
5. 模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤延迟到子类中实现。在 Spring 中，JdbcTemplate 就是一个模板方法模式的实现，它提供了一种简单的方式来执行 SQL 查询和更新操作。
6. 适配器模式是一种结构型设计模式，它允许开发人员将一个类的接口转换成另一个类的接口，以满足客户端的需求。在 Spring 中，适配器模式常用于将不同类型的对象转换成统一的接口，比如将 Servlet API 转换成 Spring MVC 的控制器接口。(装饰器感觉和动态代理差不多)
7. 策略模式是一种行为型设计模式，它定义了一系列算法，并将每个算法封装起来，使得它们可以互相替换。Spring 中的 TaskExecutor，TaskExecutor 提供了很多实现，比如以下这些：

- SyncTaskExecutor：直接在调用线程中执行任务,没有真正的异步；
- SimpleAsyncTaskExecutor：使用单线程池异步执行任务；
- ConcurrentTaskExecutor：使用线程池异步执行任务；
- SimpleTransactionalTaskExecutor：支持事务的 SimpleAsyncTaskExecutor。 这样，我们可以根据自己的需求选择不同的实现策略，使用策略模式的好处有以下这些：

1. 可以在不修改原代码的基础上选择不同的算法或策略；
2. 可减少程序中的条件语句，根据环境改变选择合适的策略；
3. 扩展性好，如果有新的策略出现，只需要创建一个新的策略类，无须修改原代码。



