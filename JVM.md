### JVM

#### 内存结构

1. jvm好处：1一次编写，到处运行  2自动内存管理，垃圾回收机制  3数组下标越界检查  4多态
2. 内存结构：程序计数器，虚拟机栈，本地方法栈，堆，方法区
3. 程序计数器：记住下一条java指令的执行地址   特点：是线程私有的，不会存在内存溢出
4. 虚拟机栈：线程运行需要的内存空间， 栈帧：每个方法运行时需要的内存(参数，局部变量，返回地址)  
5. 判断是否线程安全：变量是否被共享
6. 栈内存溢出：栈帧过多，栈帧过大
7. 本地方法栈：调用本地方法接口(C)使用的栈内存
8. 堆  特点：线程共享的，需要考虑线程安全；  有垃圾回收机制
9. 方法区：1.6 永久代(JVM内存；Class, ClassLoader, 常量池(包含StringTable))   1.8元空间(本地内存)常量池不再包含StringTable(堆中); 类是放在方法区中
10. 方法区-常量池：就是一张表，虚拟机指令根据常量表找到要执行的类名，方法名，参数类型等信息
11. 运行时常量池：常量池是.class文件中的，当该类被加载，它的常量池信息就会被放入运行时常量池，把里面的符号地址变为真实地址(.class文件是需要时加载，常量池中的信息也是)
12. StringTable: 字符串常量池
13. 字符串采用延迟加载的机制，常量池中的字符串只是符号，只有在用到时才会转化为对象；字符串常量拼接的原理是编译器优化(在StringTable中寻找)；intern方法；
14. new字符串会产生两个对象分别在堆和StringTable中
15. String str =“a” + “b” 创建了1个字符串对象，在java堆中的常量池中(编译器优化)      栈创建的是变量而非对象
16. String str = new String(“a”) + new String(“b”) 会创建至多6个，其余两个是StringBuilder对象和堆中的ab对象，StringBuilder.toString方法不会在常量池创建对象
17. 因为StringTable是由HashTable实现的，所以可以适当增加HashTable桶的个数，来减少字符串放入串池所需要的时间
18. 直接内存是操作系统和 Java 代码都可以访问的一块区域，无需将代码从系统内存复制到 Java 堆内存，从而提高了效率；常用于NIO操作的数据缓冲区，分配回收成本较高，单读写性能高，不受JVM内存回收管理
19. 直接内存的回收不是通过 JVM 的垃圾回收来释放的，而是通过unsafe.freeMemory 来手动释放。

#### 垃圾回收 Gabage Collection

目录：如何判断对象可以回收， 垃圾回收算法， 分代垃圾回收， 垃圾回收器， 垃圾回收调优；

​            垃圾回收算法是对内存的操作，垃圾回收器是回收策略(吞吐量和时间的平衡)，可以由多种垃圾回收算法组合起来使用

1. 判断对象是否可以回收：引用计数法(循环引用无法释放)； 可达性分析算法：GC Root对象为起点的引用栈链找不到的对象可以被回收
2. GC Root：栈帧的本地变量，方法区(static, final), 本地方法栈JNI引用的对象
3. 四种引用：强引用，软引用(垃圾回收后内存仍不足)，弱引用(垃圾回收时无论内存是否充足)，虚引用(必须配合引用队列使用，主要配合ByteBuffer使用，软弱可以配合引用队列释放自身)，终结器引用(第二次GC才能回收对象，第一次终结器引用入队，效率较低)
4. finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作，是对该对象调用的
5. 垃圾回收算法：1标记清除(速度较快，会产生内存碎片)  2标记整理(速度慢，没有内存碎片)   3复制(不会有内存碎片，需占用两倍内存空间)
6. 分代垃圾回收：新生代(伊甸园，from, to幸存区)  老年代
7. 新生代空间不足触发minor gc(会引发stop the world, 暂停其他线程)；老年代空间不足是先触发minor gc，仍然不足再触发full gc
8. 垃圾回收器：串行(单线程)，吞吐量优先(多线程，堆内存较大，单位时间内总STW最短，并行)，响应时间优先(多线程，堆内存较大，STW的单次时间最短，有一个并发标记的阶段；包括初始标记(STW，只标记GC Root的下一级)，并发标记，重新标记(STW，没有阻塞其他线程产生的新垃圾)，并发清理)    标记时会使用到队列
9. CMS(Concurrent Mark Sweep)就是响应时间优先，基于标记清除算法；问题1内存碎片；2并发回收导致CPU资源紧张；3无法清理浮动垃圾；4并发失败，预留给并发的进程内存不够，触发full GC
10. G1(Garbage First)收集器：同时注重吞吐量和低延迟，超大堆内存会划分为多个大小相等区域，整体是标记-整理算法，两个区域之间是复制算法；  包含了三个阶段，
11. 1Young Collection：对新生代垃圾收集  2Young Collection + Concurrent Mark：如果老年代内存到达一定的阈值了，新生代垃圾收集同时会执行一些并发的标记。
    3Mixed Collection：会对新生代 + 老年代 + 幸存区等进行混合收集，然后收集结束，会重新进入新生代收集。为了低延迟选择回收最有价值的老年代
12. G1 把 Java 堆划分为多个大小相等的独立区域（Region），每个区域都可以扮演新生代（Eden 和 Survivor）或老年代的角色；还有专门为大对象设计的 Region，叫 Humongous 区；这种区域化管理使得 G1 可以更灵活地进行垃圾收集，只回收部分区域而不是整个新生代或老年代
13. G1：1初始标记；2并发标记；3最终标记(对用户线程短暂暂停)；4清理阶段(必须暂停用户线程，多条回收器线程并行完成)：
14. 清理阶段：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。
15. 老年代内存不足时，如果垃圾产生速度慢于垃圾回收的速度则不会触发Full gc
16. 新生代调优：新生代内存不是越大越好(太小频繁触发Minor GC，太大老年代频繁触发Full GC，且新生代清理时间过长)    老年代调优(内存越大越好)

#### 类加载与字节码技术

1. 栈帧中包括stack, locals(参数存放)；方法区存放了.class文件，也就是一行行指令，基本数据类型的值1234也存放在class文件中；赋值是先入栈，然后再出栈赋值给locals的变量；运算是从locals取值入栈再进行计算(注意i++, ++i的顺序)
2. 编译器会按照从上到下的顺序，收集所有static静态代码块和静态成员赋值的代码，合并成cinit()V; 所以按顺序赋值就行；而init()V也是顺序收集代码块和赋值(无static)，构造方法赋值总是排最后
3. 代码块与构造方法的顺序是: 静态优先，父优先，普通代码块与构造方法绑定，静态只在初始化时执行一次
4. 多态原理：普通成员方法在运行时才能确定具体的内容(其他都是静态绑定，在编译期间就确定了方法的内容)；构造方法，final, private都是invokespecial;  static是invokestatic; 普通方法是invokevirtual
5. 异常处理try-catch:    catch会多出一个Exception table的结构，finally的代码会被复制3份保证执行，若finally里有返回值会吞掉throw不抛出异常，所以不能返回；
6. Synchronized
7. 语法糖：编译器编译过程中自动生成和转换的一些代码(体现在.class文件)；  1默认构造器，2自动拆装箱， 3泛型集合取值， 4可变参数， 5foreach循环， 6switch字符串/枚举， 7枚举， 8try-with-resources, 9方法重写时的桥接方法， 10匿名内部类，
8. 类加载阶段：1)加载   java类采用c++的instanceKlass描述，并提供_java_mirror互相暴露指针给java使用，存在于本地内存元空间方法区，mirror保存在堆中，类实现的对象保留了.class的地址，从而可以获取类的各种信息
9. 2)连接  包括验证和准备    准备：static变量存储于mirror末尾，其分配空间和赋值是两个步骤，分别在准备阶段和初始化阶段完成；例外：final 准备阶段就赋值完了(基本类型和字符串常量，其他引用类型会将常量池中的符号引用解析为直接引用)
10. 3)初始化   调用\<cinit>()v方法   类初始化是懒惰的，用到再初始化(Class.forName)    不初始化的情况：访问static final静态常量(字符串和基本类型)时，instance.class时，创建类的数组                   典型应用：懒惰初始化单例模式   能保证初始化时的线程安全
11. 类加载器：比较同一个类是否相等时必须是在同一个类加载器加载的
12. Bootstrap启动类加载器(显示为null); Extension拓展类加载器；Application应用程序类加载器(加载在classpath目录下的类)；自定义加载器(继承ClassLoader类，重写loadClass方法和findClass方法)
13. 双亲委派模型：调用类加载器ClassLoader的loadClass方法时，查找类的规则
14. 打破双亲委派模型：
15. 自定义加载器：想加载非classpath随意路径的类文件   重写findClass方法(不想打破双亲委派就重写findClass，想打破需要就重写findCLass和loadClass方法)
16. 运行期优化   一、即时编译       1) 分层编译(执行状态分为5层  解释器，C1(不带/带基本/带完全profiling程序执行状态的数据)，C2)  ：对于重复的代码(热点代码)，不再解释器一行一行解释，利用即时编译器编译保存重复代码的机器码(机器码不同平台不一样)      2)方法内联   3)字段优化(缓存)   
17. 4)逃逸分析，分析新创建对象的范围，并决定是否在堆上分配内存，如果没有逃逸，可以 1锁消除(Vector, StringBuffer只在当前线程用到会移除锁操作)  2标量替换(只创建对象用到的成员标量不用创建对象本身)  3栈上分配
18. 二、反射优化  超过调用阈值时，本地方法访问器会替换为一个运行时动态生成的访问器，提高效率

#### JAVA内存模型JMM

1. 定义了一套在多线程读写共享数据(成员变量，数组)时，对数据的可见性，有序性，原子性的规则和保障
2. 原子性–不受线程上下文切换的影响； 可见性：不受cpu缓存的影响(即时编译)； 有序性：不受cpu指令并行优化的影响(JVM优化指令重排)
3. 可见性+volatile     synchronized既保证原子性，也保证代码块内变量的可见性，但性能较低
4. volatile修饰的变量可以禁止指令重排，禁止该变量之前的代码重排序    
5. volatile原理：内存屏障，对volatile变量的写指令后加入写屏障，读指令前加入读屏障；把volatile变量的改动以及的代码普通变量改动都会同步到主存当中，读屏障加载的是主存当中的最新数据(读取的是哪些普通变量)
6. CAS(compare and Swap) 乐观锁的思想，不断尝试直到成功；适用于竞争不激烈，多核CPU场景
7. 乐观锁思想：改了没关系，自己吃点亏；  悲观锁(sychronized):防着别人改
8. synchronized优化：  1)轻量级锁





#### 面试小抄

1. JMM(Java Memory Model)定义了一套在多线程读写共享数据(成员变量，数组)时，对数据的可见性，有序性，原子性的规则和保障；定义了主存（共享内存）、工作内存（线程私有）抽象概念
2. JVM常量池主要分为**Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池**(除了两个浮点数包装类，其他包装类需<=127才能使用常量池)
3. G1回收过程四个阶段：初始标记，并发标记，最终标记，清理阶段
4. 类加载：虚拟机把描述类的数据加载到内存里面，并对数据进行校验解析初始化，最终变成可以被虚拟机直接使用的class对象
5. 过程：1加载(在堆中生成一个class对象)  2验证(验证字节流信息是否符合虚拟机的要求，不会威胁到jvm安全)  3准备(分配空间和赋值)  4解析(将符号引用转化成直接引用)  5初始化(调用类构造器)
6. 类加载器是指：通过一个类的全限定性类名获取该类的二进制字节流叫做类加载器；启动类加载器(加载核心类库)；扩展类加载器(扩展库)；应用程序类加载器(类路径)
7. 双亲委派模型：当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类
8. 为了防止内存中出现多个相同的字节码；因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性
9. 避免类的重复加载，防止核心类不被篡改
10. 双亲委派的作用：1防止加载同一个.class，加载过了就不需要重新加载，保证了数据安全；2保证核心.class不被篡改，即使被篡改也不会被加载，即使被加载也不是同一个class，因为不同的加载器加载同一个.class也不是一个class对象，保证了class的执行安全
11. Tomcat中可以部署多个web项目，为了保证每个web项目互相独立，所以不能都由AppClassLoader加载，所以自定义了类加载器WebappClassLoader，WebappClassLoader继承自URLClassLoader，重写了findClass和loadClass，并且WebappClassLoader的父类加载器设置为AppClassLoader。
    WebappClassLoader.loadClass中会先在缓存中查看类是否加载过，没有加载，就交给ExtClassLoader，ExtClassLoader再交给BootstrapClassLoader加载；都加载不了，才自己加载；自己也加载不了，就遵循原始的双亲委派，交由AppClassLoader递归加载。
12. Tomcat1为了保证每个Web项目相互独立，不能都由App加载，所以需要自定义类加载器；2与Jvm一样的安全性问题，使用单独的classloader去装载tomcat自身的类库，以免其他恶意或无意的破坏
13. 列举打破双亲委派机制的例子，解释为什么要打破双亲委派模型：1)Tomcat：应用的类加载器优先自行加载应用目录下的class；三个目的：一、对于各个webapp中的class和lib，需要相互隔离，不能出现一个应用中加载的类库会意向另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源  二、与jvm一样的安全性问题，使用单独的classloader去装载tomcat自身的类库，以免其他恶意或无意的破坏   三、热部署
14. 2)OSGi，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。打破的原因是为了实现模块热替换(在应用运行时更新应用程序，而不需要停止和重新启动整个服务器)
15. 3)JDK 9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。



















