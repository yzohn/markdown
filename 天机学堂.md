#### 天机学堂

1. 项目亮点
   1. 电商：对接多种支付平台，优惠券系统设计方案，库存超卖解决方案；秒杀抢购解决方案，超时订单处理方案；
   2. 在线学习：视频点播方案，学习辅助系统，考试测评系统
   3. 社交互动：互动问答系统，课程评价系统，通用点赞实现方案，积分系统实现方案，排行榜实现方案
2. 虚拟机中部署了各种公共服务，我们在本地开发和运行未完成的微服务，模拟真实企业开发环境
3. jenkins：持续集成工具，目前已经添加了所有部署脚本和Git钩子，代码推送会自动编译，可以根据需求手动部署；当我们push代码时，就会触发项目完成自动编译和打包
4. jenkins：从远程仓库拉取代码，然后经过编译和打包生成.jar文件，然后部署到服务器，先制作镜像再创建容器
5. 虚拟机部署：需要运行某个微服务时，1访问jenkins；2点击对应微服务后面的运行按钮；完成后可以在Nacos控制台看到微服务注册成功；部署完成可访问前端界面
6. 本地部署：对于需要开发功能的微服务，需要在本地部署(本地运行时，需要将debug Configurations上的Active profiles设置为local)；此时Nacos包含两个示例，分别是虚拟机IP和本地IP
7. Spring推荐依赖注入方式为构造函数，@RequiredArgsConstructorprivate final IOrderService
8. 远程调试，在Edit Configurations上选择Remote JVM Debug，填写参数；然后再jenkins点击配置好的相应微服务模块的debug脚本
9. 直接本地调试：将微服务的active.profiles设置为local，debug启动会注册到nacos，且IP为192.168.150.1；在nacos上将101的实例改为下线状态(等于就是直接调试本地的代码)
10. Nginx：流量网关(负载均衡，反向代理，全局的api管理策略，多用户分配多网关)；gatewa：业务网关(针对具体的业务，路由鉴权，负载均衡)

##### 2课表

1. 网关：1过滤器校验token，解析用户信息userId；2将用户信息存入请求头
2. 微服务中的拦截器：1获取请求头的用户信息，保存到ThreadLocal，在auth模块下
3. openFeign远程调用时，通过openFeign的拦截器判断ThreadLocal是否有userId，放入Feign请求头
4. 我的课表(learning_lesson)每条对应一个课程及其相关时间、状态信息，最近学习小节信息，结合接口设计需要连表查询课程/小节等具体信息，调用openfeign的api
5. lesson(用户id，课程id，课程状态，每周学习频率，学习计划状态，已学习小节数量，最近学习小节id，最近学习时间，创建时间，过期时间)
6. 实现接口功能：1添加课程到课表；2分页查询我的课表；3查询正在学习的信息；主要还是连表查询课表，添加course到lesson

##### 3学习计划和进度

1. lesson(用户id，课程id，课程状态，每周学习频率，学习计划状态，已学习小节数量，最近学习小节id，最近学习时间，创建时间，过期时间)；
2. learning_record(课程id，小节id，用户id，视频当前观看时间点，是否完成，创建时间，更新时间)；
3. 课程lesson包含多个小节，包含学习计划(状态和频率)，包含的小节情况，时间；record只针对小节，所以只关注学到哪了和是否完成
4. 实现接口功能：1查询学习记录；2提交学习记录，分为视频和考试，需要判断是否完成该章节，先更新record，再更新lesson；3创建学习计划，更新课表；4查询学习计划进度，按照课程统计完成小节数/总小节数
5. 面试：主要是提交学习记录，实现视频续播功能，要求：1时间误差控制在30s以内；2用户突然断开或切换设备都可以继续上一次播放；
6. 实现：1切换设备还能续播，用户的进度必须保存在服务端而不是客户端；2误差不超过30s，播放进度的记录频率要比较高，前端每隔15s发起一次心跳请求，提交最新进度保存到客户端，下一次续播总结读取服务端的播放进度

##### 4高并发优化方案

1. 解决高并发问题三个方向：1提高单机并发；2水平扩展(做好负载均衡)；3服务保护(服务熔断，降级保护，提高服务的高可用性)；后两种侧重的是运维层面的处理，提高单机并发能力侧重的是业务层面的处理，是开发中可以做到的
2. 提高单机并发能力(缩短业务的响应时间，响应时间影响最大的是数据库的操作)
3. 对于读多写少的业务：1优化代码和SQL；2添加缓存
4. 对于写多读少的业务：1优化代码及SQL；2变同步写为异步写；3合并写请求(缓存到redis)
5. 使用合并写请求方案处理：设置一个延迟任务并保存这次提交的进度，等待20秒后(前端15秒提交一次)，检查redis中的缓存的进度与任务中的进度是否一致，不一致说明持续在提交无需处理
6. DelayQueue(JDK自带延迟队列，基于阻塞队列实现，获取剩余延迟时间并比较，判断执行顺序)：
7. 针对视频中非第一次学完的多次写请求分支，用redis缓存record，通过判断数据是否一致，判断视频进度(momet)是否持续改变，在未完成(50%)之前，更新record和lesson；完成后则需要更改record和lesson中完成小节数量和状态，此处需要删除record缓存；
8. hash: key(lessonId),  HashKey(sectionId), HashValue(redis缓存的是record的id, finished, moment)
9. 如果采用sectionId作为key，创建的key过多，大量浪费内存，并且多个视频来回跳转时，会导致频繁的创建缓存和缓存过期，影响业务性能
10. 采用lessonId作为key，可以大大减少需要创建key的数量，减少内存占用，并且在多个视频跳转时，整个缓存的有效期都会被延续，不会频繁创建和销毁数据(redis过期键值删除以key为单位删除的)
11. 使用多线程也就是把代码逻辑扔进run函数里
12. 面试：前端每隔15s发起一次心跳请求，如果在用户量较大时全部写入数据库，对数据库压力比较大，因此采用合并写请求的方案，先缓存在redis，后续再使用延迟任务将数据保存到数据库，由于播放进度会不断覆盖，只需要保留最后一次即可，可以大大减少对数据库的访问次数和访问频率

##### 5问答系统

1. 问题表(interaction_question)：title, description, course_id, chapter_id, section_id, user_id, latest_answer_id, answer_times(回答数量), anonymity, hidden, status, create_time, update_time 
2. 回答或评论表(interaction_reply)：question_id, answer_id, answer_id, user_id, content, target_user_id, target_reply_id, reply_times, liked_times, hidden, anonymity
3. 用户端分页查询question，并且同时查询提问者用户id，以及最近一次回答answer，封装在一起
4. 管理端分页查询：使用ES根据课程名称模糊查询课程id；使用Caffeine建立多级缓存
5. caffeine使用应用程序所在的JVM堆内存来缓存数据，适合作为一级缓存；redis是一个远程缓存系统，通常作为一个独立的服务运行，存储在服务器内存中，由于是一个远程服务，访问数据时需要通过网络通信
6. caffeine三种缓存驱逐策略：1基于容量(设置缓存的数量上限)；2基于时间(设置有效时间)；3基于引用(软/弱引用，利用GC回收)
7. 

##### 6点赞系统

1. liked_record(user_id, biz_id点赞的业务id, biz_type,  create_time, update_time)
2. 点赞系统被抽取为一个独立的服务，先判断是点赞or 取消点赞，先保存点赞记录(更改like_record表)，然后使用MQ将查询到的总点赞数量通知其他微服务，业务方再更新自己的点赞数量
3. RabbitMQ使用Topic类型的交换机，结合不同的RoutingKey，让不同的业务方监听不同的key
4. 在api中提供openFeign RemarkClient的接口，并编写fallback降级降级逻辑(sentinel)，继承FallbackFactory接口，可以在服务停止或者远端调用超时时提供降级服务(可以直接返回null)；还需在spring.factories(启动时读取)指定FallbackConfig类，springboot会自动装配加载配置
5. 点赞功能改进(redis)：1用户是否点赞  ：Set集合：key: bizId,  value:userId
6. 2点赞次数：Zset(移除查询操作具备原子性)：key:bizType,  member:bizId,  score:likedTimes
7. 从节省内存的角度应该选择hash，但是考虑到要从redis读取点赞数，然后移除(避免重复处理)，为了保证线程安全，查询、移除操作需具备原子性，Zset提供几个移除并获取的功能并且具备原子性，并且每隔一段时间就会将数据从redis移除，不会占用太多内存，因此选用Zset
8. 点赞数据入库持久化：和之前提交播放记录业务不一样，播放记录是定期发送请求频率固定，所以能通过数据变更判断是否有新数据到达，大部分情况下，通过定时任务，定期将缓存的数据持久化到数据库中
9. 定时任务是先  读取并移除redis缓存的点赞总数，移除是为了避免重复处理
10. 定时任务SpringTask，遍历bizType业务类型，同时也可以设置每次处理的最大业务数量，定时发送MQ消息
11. 面试：1点赞系统如何设计：1项目中需要用到的点赞的业务不止一个，因此需要具备通用性和独立性，抽离出来作为一个独立服务；2点赞业务可能具有较高的并发，用redis保存点赞记录和点赞数量，利用定时任务定期将点赞数量持久化到数据库中
12. set介绍：保存点赞记录使用set结构，key是业务类型+业务id，值是用户id，sadd, srem, sismember判断是否点赞, scard统计点赞数量，reids的set结构会在头信息中保存元素数量，scard直接读取该值，性能好
13. Zset：点赞需要定期将点赞数持久化到数据库，只用set无法知道哪些业务的点赞数发生了变化，zset可以理解为一个待持久化的点赞任务队列，定时任务开启时，只需要从zset获取并移除数据，然后发送MQ给业务方，并持久化到数据库即可；底层是哈希+跳表(可以排序)，member有唯一性，所以多次添加会覆盖旧的点赞数量，只需要持久化一次；不足在于内存有额外占用，但是数据会定期移除，可以接受
14. 

##### 7积分系统

1. 业务包括 签到、积分、排行榜
2. 签到sign_record: user_id, year, month, date, is_backup是否补签
3. 积分points_record: user_id, type积分方式, points, create_time；因此一个用户可能产生多条积分记录
4. bitmap:     setbit name offset value;      bitfield key get encoding offset返回十进制
5. 签到功能：利用bitmap签到，然后计算连续签到时间(右移>>>  &1)，连续签到xx天增加积分
6. 新增积分：当发生签到、完成学习、回答问题等业务，利用MQ发送消息保存积分明细，按照积分获取规则(加分，每天获得积分有上限)save保存积分记录
7. 面试：1签到使用bitmap结构，用bit位来表示签到数据，31bit位就能表示一个月的签到记录，节省空间，同时查询效率也比较高
8. redis的高可用数据安全问题：1添加持久化机制，如AOF；2搭建主从集群，再结合redis哨兵，主节点会把数据持续同步给从节点，宕机后哨兵会重新选主，不用担心数据丢失问题；3对数据的安全性要求较高，还是得使用mysql，数据量过大对数据进行分表处理
9. 

##### 8排行榜功能

1.  赛季表points_board_season: name, begin_time, end_time
2. 排行榜points_board: user_id, points, rank名次, season
3. 使用zset实现排序功能(缺点会一直占用redis的内存)，在用户规模达到数千万时，可以将用户数据按照积分范围划分为多个桶(1~100分)，为每个桶创建一个key，减少单个key的数据规模，计算排名时查询所在桶并累加分值更高的桶的用户数量即可
4. 实时排行榜：zset:  key:赛季日期，  member: user_id,  score: 积分和，保存在redis
5.  保存积分记录时更新总积分到Redis，查询当前赛季积分榜可以利用zset做范围查找
6.  历史排行榜：保存在DB；查询积分榜融合为一个函数，在函数内判断是当前赛季还是历史赛季，当前赛季在redis上查，历史赛季在mysql上查
7.  数据库的海量数据存储：分区，分表，分库，集群
8.  表分区：对数据进行水平拆分，增删改查方式不变，底层处理上的变化；
9.  分表：逻辑上和物理上都变成了多张表，增删改查方式发生变化，需要自己考虑去哪张表做数据处理(水平分表和垂直分表)
10.  分库和集群；垂直分库和水平分库
11.  point_board排行榜按照season进行水平分表，开启定时任务(每月初执行)，创建该赛季对应的分表；  points_board_seasonX(id, user_id, points)
12.  分布式任务调度：以上定时任务是基于SpringTask实现，存在问题：1微服务多实例部署时，定时任务会被执行多次；2除了创建表还要定期持久化数据，SpringTask无法保证多个定时任务能够按照顺序依次执行
13.  分布式任务调度原理：普通定时任务会有两个组件：任务和任务触发器，因此各个实例各自运行，无法统一控制；所以分布式任务调度把任务触发器提取到各个服务实例之外，去做统一的触发和调度
14.  XXL-JOB：分为执行器和调度中心；1在XXL-JOB控制台注册新增执行器；2配置任务调度(调度配置cron表达式；任务配置@XxlJob注解的任务名称；路由策略：由哪个执行器执行 轮询)
15.  榜单持久化：1创建表；2持久化redis数据到DB；3清理redis数据
16.  利用MybatisPlus动态表名的插件计算分表名，再将表名存入ThreadLocal；持久化如果采用while死循环，不停查询数据知道所以数据持久化完成，若是数据量庞大会耗费非常多时间，因此采用多实例部署，许多执行器并行执行，引出任务分片，确保每个执行器不会都从第一页开始逐页处理数据导致重复处理
17.  XXL-JOB任务分片：避免在多实例部署情况下多个任务执行器重复处理相同代码(持久化)的情况，因此需要确保任务不重复(扑克牌发牌原理)；可以api获取执行器数量和执行器编号，这样就能将不同job分发到不同JobHandle执行器
18.  持久化完成后，还需要清理上赛季的榜单数据，也是利用@XxlJob
19.  任务链：控制三个任务的执行顺序：1创建榜单表；2持久化redis上赛季榜单；3清理上赛季缓存；使用XXL-JOB的子任务功能，将后执行的任务作为子任务(可嵌套)，使得任务依次执行；因此这三个子任务都是在月初同一时间完成
20.  面试：1排行榜怎么设计实现的：1产品设计是每个月为一个赛季，月初清零积分记录，让学员有持续动力学习，因此也有了当前赛季榜单和历史榜单的区别；当前赛季榜单采用zset，当用户产生积分行为时就会更新Score值，zset自动形成榜单
21.  历史榜单保存到数据库中，由于数据过多，需要做水平拆分，即按照赛季来拆分，也就是每一个赛季单独一张表，好处是：1拆分数据时比较自然，无需做额外处理；2查询数据时往往是按照赛季来查询，这样一次只需要查一张表，不存在跨表查询问题；
22.  实现：不需要用到分库分表的插件，直接在业务层利用MybatisPlus实现动态表名，动态插入简单高效；利用定时任务每月初先生成上赛季的榜单表，再持久化，最后清理redis历史数据；三个任务依次执行，之所以分开是为了避免任务耦合，在任务失败时可以单独重试，无需从头重试
23.  2 Zset如果用户量非常多怎么办：Zset利用了跳表机制，性能上可以得到保证，当用户规模达到数千万时可以采用分治的思想，将用户数据按照积分范围划分为多个桶，为每个桶创建一个key，这样可以将数据分散，减少单个key的数据规模；计算排名时，只需要按照范围查询出用户积分所在的桶，再累加分值范围比他高的桶的用户数量即可，简单高效
24.  3定时任务框架xxl-job，如何分片，如何确保多个任务依次执行：1xxl-job自带分片广播机制，每一个任务执行器都能通过api得到自己的分片编号和总分片数量，然后按照扑克牌发牌的方式分别处理不同页的数据，如135，246，这样能够确保所有数据都被处理，且每个执行器执行的是不同数据；     2 要保证多个任务的执行顺序，可以利用xxl-job的子任务功能，将b设为a的子任务，然后给a设置一个触发器，当a触发时，会依次执行所有任务
25.  

##### 9优惠券管理

1. 优惠券coupon：
2. 优惠券课程使用范围coupon_scope：type, counon_id, biz_id
3. 兑换码exchange_code：code, status, user_id, type, exchange_target_id, expired_time
4. 优惠券管理：新增优惠券，分页查询优惠券；优惠券发放：修改优惠券的一些信息(状态时间这些)
5. 兑换码生成算法：使用自增id作为兑换码，利用Base32加密，每5个二进制为一组=32，对应24个字母和8个数字，转为对应字符，这种把二进制经过加密得到字符的算法就是Base32法；
6. 重兑校验算法：基于BitMap，自增id对应一个bit位
7. JWT的头部和载荷采用base64算法，几乎是明文传输，为了防止其他人伪造、篡改token，采用验证签名，签名是密钥结合头部和载荷 利用 MD5或者RSA算法生成的，只要密钥不泄露，就无法伪造签名和token，篡改后的token计算得到的签名肯定不一致，会被判定为无需token
8. 防刷校验算法：仿造  JWT技术(头部，载荷，签名)+密钥； 
9. 所采用的签名算法：将自增id(32位)没4位分为一组，共8组转为10机制，每一组不同权重，计算权重和，得到的结果就是签名；自增id就是兑换券的主键，通过主键查找exchangeCode找到对应的优惠券
10. 密钥：权重；签名：权重和(权重x自增长序列号)；新鲜值(多个权重)；   兑换码=签名+新鲜值+自增长序列号(14位+4位+32位)
11. 异步生成兑换码：线程池异步生成@Async(“自定义线程池的名字”)  ；将生成的兑换码保存在数据库中，并且redis记录最大的自增id(兑换码的最大序列号)
12. 面试：兑换码生成方案：
    1. 首先考虑兑换码验证的高效性，最佳方案是自增序列号，可以借助bitmap验证兑换状态，不需要查询数据库，效率高；32位的兑换码支持42亿的数据规模；
    2. 为了防止爆刷，需要设计加密验签算法，采用按位加权的方案，32位8位一组，准备长度为8的加权数组作为密钥，签名是按位加权和；
    3. 再考虑到密钥的安全性，准备16组的加权数组，随机生成4位的新鲜值，兑换码就是签名+新鲜值+自增长序列号
13. 线程池的使用：1发放优惠券时，如果是兑换码领取，会在发放的同时生成兑换码，由于数量过多，业务耗时比较久，因此采用线程池异步生成兑换码的方式；核心线程数是2，最大线程数是CPU核数，因为生成兑换码并不是高频业务，仅仅为了减少耗时，所以线程数不需要特别高；队列大小200，拒绝策略采用交给调用线程处理的方式
14. 

##### 10领取优惠券

1. 用户券user_coupon：user_id, coupon_id, term_begin_time, term_end_time, used_time, status, create_time, update_time
2. 登录权限问题：tj-auth模块，使用拦截器，在注册拦截器时，从authProperties配置文件中获取是否需要被拦截的路径
3. 领取优惠券：先查询发放中的优惠券，需要对coupon的总量、是否发放和user_coupon的领取次数做逻辑上的判断；领取优惠券也就是判断各种条件，然后修改user_coupon
4. 兑换码兑换优惠券，解密得到exchangeCode自增主键，再找到对应的优惠券，验证是否存在、过期、超出限领数量，最后生成用户券，更新兑换码状态
5. 并发安全问题：先查询，再判断(优惠券库存是否充足)，再更新的操作   共享资源但不具备原子性
6. 1超卖问题(先判断优惠券库存是否充足，再数据库更新领取数量)：乐观锁直接在sql更新coupon时判断：  AND issue_num < total_num 更新失败返回值0，应该抛出异常(库存不足)，触发回滚(@Transactional)
7. 超卖是指coupon里issue_num字段超过total_num，更新库存上的问题
8. 2锁失效问题：除了优惠券库存判断，领券时还有对于用户限领数量的判断，但是用户与优惠券的关系不具备唯一性，并且乐观锁也常用在更新上(这是新增)，因此只能采用悲观锁：synchronized(userId.toString().intern())，同一个用户用同一把锁，toString是采用new String的方式，所以加上intern保证返回的是常量池里的同一个对象
9. 用户限领数量是在新增用户券时，新增不需要判断条件无法使用乐观锁
10. 3事务边界问题：经过同步锁的改造，仍然存在用户超过领取数量的现象，由于锁过早释放，导致了事务尚未提交，判断出现错误，事务边界和锁边界的问题；解决方案：锁的范围需大于事务的范围；抽取子方法，在子方法上加上@Transactional (事务方法需加public修饰，并且被spring管理，需要抽取到service接口)；用synchronized锁住子方法，保证锁边界大于事务边界
11. 4事务失效问题：
    1. 事务方法非public修饰，由于spring的事务是基于AOP结合动态代理实现的，因此事务方法一定要是public，才能便于被spring做事务的代理和增强
    2. 非事务方法调用事务方法(\*)：对于事务方法，spring会生成一个动态代理对象实现事务效果，非事务方法则是直接调用原始方法而非代理对象的代理方法，导致事务失效；
    3. 事务方法的异常被捕获了：spring的事务管理需要感知业务方法的异常，当捕获到异常后才会回滚，如果代码直接try catch了Exception类型的异常，那么spring无法感知，不会回滚导致事务失效
    4. 事务异常类型不对：spring默认感知的异常类型是RuntimeException，当事务方法内部抛出非运行时异常(如IO)时，事务失效；可@Transactional(rollbackFor=Exception.class)
    5. 事务传播行为不对：子事务方法定义为require_new，成为一个独立事务，无法一起回滚
    6. 没有被spring管理：未添加@Service，没有被Spring管理
12. 非事务方法调用事务方法  解决方法：获取代理对象；1引入AspectJ依赖；2启动类加注解，暴露代理对象；3使用代理对象
13. 面试：1如何解决优惠券的超发问题；2spring事务失效的情况；3开发中的遇到的困难：并发安全的问题…
14. 

##### 11领取优惠券的优化

1. synchronized是单机模式下的多线程解决方案，在集群模式(多实例部署)下，需要使用分布式锁，需满足1多JVM实例都可以访问；2互斥

2. SET lock thread1 NX EX 20；保证了setnx和expire两个操作的原子性； deal lock；   使用范式  try{  if(!isLock)  else} finally{lock.unlock}

3. 存在问题：

   1. 锁误删问题：线程1准备释放锁时阻塞，直到超时释放，然后释放了线程2的锁(需判断当前锁标示是否是自己)
   2. 获取完锁标示后又阻塞，再一次误删
   3. 误删原因：1超时释放；2判断锁标示、删除锁两个动作不是原子操作
   4. 其他问题：1锁重入问题；2失败不支持重试问题；Redis主从的一致性问题
   5. 解决方案：1原子性，利用LUA脚本确保原子性；2超时问题，watchdog机制，获取锁成功时开启定时任务，锁到期自动续期，服务宕机跟着停止运行；3锁重入问题：放弃setnx，利用Hash记录锁的持有者以及重入次数；4主从一致性问题：RedLock机制

4. Redisson，使用上只需要写获取锁成功or失败的处理代码，因此改造为基于注解的分布式锁，基于AOP的思想，将业务代码作为切入点，将业务前后的锁操作作为环绕增强
   1. 定义注解
   2. 定义切面，获取锁失败抛出’请求过于频繁‘ 异常，成功则执行业务；Spring中的AOP切面按照order排序的优先级执行，Spring事务AOP的优先级最低，为使分布式锁先于事务执行，切面需执行ordered接口，指定order值小于事务的max_value
   3. 使用锁，直接在子方法上加注解@MyLock 和@Transactional
   4. 存在问题：1锁的种类写死了；2获取锁的逻辑没有设置，如锁失败的重试策略；3锁名称写死

5. 工厂模式切换锁类型：1锁类型枚举；2MyLockFactory，定义一个Map，key是string枚举，value是创建锁对象的Function，Function执行.apply(name)方法得到锁对象

6. 锁失败策略：1是否重试：不重试，有限次数重试，无限重试；2重试失败策略：直接结束，抛出异常；采用策略模式(定义一系列算法并封装起来(同一接口的不同实现类的方法)，使得可以相互替换)

7. 简化策略模式：使用枚举代替策略工厂，在锁注解中定义策略模式接口，然后调用实现方法

8. 基于SPEL的动态锁名：SPEL表达式，动态获取任意参数  @Lock(name=“lock:coupon:#{userId}”) 在切面中动态解析；  锁的对象是当前登录的用户userId

9. **异步领券**：领取优惠券的业务逻辑比较复杂，包含大量查询校验和写数据库操作，并且过程中还加锁保证线程安全，接口串行化执行极大影响性能

10. 合并写请求适合应用在写频率较高，写数据比较简单的场景；异步写适合应用在业务比较复杂，业务链较长的场景(减少阻塞，提高资源利用率)

11. 将更新发放数量和新增用户券的数据库操作变更为MQ异步操作，同时校验部分可以把优惠券相关数据缓存到redis中，基于redis完成资格校验，提高效率

12. 优惠券资格校验的内容包括：优惠券发放时间、优惠券库存、用户限领数量；同时还需记录用户领取数量；利用Hash结构保存；  key是couponId,  field   value是校验数据

13. 发放(注意是发放，为领取优惠券时查询redis缓存做准备)优惠券的同时总结添加优惠券缓存，暂停发放时应该将缓存删除，同时对于延时发放的优惠券需要编写定时任务，扫描发放时间到了的优惠券添加缓存，过期时间定时删除

14. 校验从redis中取值，异步更新用户券的锁可以移至校验部分，并将@MyLock的name从userId改为id(coupon)

15. 资格校验时会有多次与redis的交互，每次交互都需要发起一次网络请求，在并发较高的时候可能导致网络拥堵，redis提供了LUA脚本，可以在脚本中编写复杂业务判断，只需要发起一次请求就可以完成脚本调用，完成复杂业务校验

16. **面试**：券超发问题常见的两种场景：1券库存不足导致超发；2发券时超过用户限领数量；

17. 1是典型的库存超卖问题，通过乐观锁解决，也就是SQL语句中添加对库存余量的判断，不必要求一致会导致失败率太高，只需要判断库存是否大于零即可，即保证安全，又提高库存扣减的成功率

18. 2无法使用乐观锁，因为需要先查询用户领取数量，再判断有没有超过限领数量，没有超过才会新增，后续的新增会影响超发的判断，只能用悲观锁封装为原子操作，保证线程的安全

19. 悲观锁如何实现：项目中优惠券服务是多实例部署形成的负载均衡集群，考虑到分布式下JVM锁失效的问题，采用了基于Redisson的分布式锁，并且利用自定义注解，AOP以及SPEL表达式实现了基于注解的分布式锁； 

20. 封装的时候用了工厂模式来选择不同的锁类型，利用了策略模式来选择锁失败重试策略，利用SPEL表达式来实现动态锁名称；   具体策略：获取锁可能会失败嘛，失败后可以重试，也可以不重试。如果重试结束可以直接报错，也可以快速结束。综合来说可能包含5种不同失败重试策略。例如：失败后直接结束、失败后直接抛异常、失败后重试一段时间然后结束、失败后重试一段时间然后抛异常、失败后一直重试

21. 加锁后性能会比较差，解决方法：利用MQ来做异步领券，起到一个流量削峰和整形的作用，降低数据库压力；具体来说，我们可以将优惠券的关键信息缓存到Redis中，用户请求进入后先读取Redis缓存，做好优惠券库存、领取数量的校验，如果校验不通过直接返回失败结果。如果校验通过则通过MQ发送消息，异步去写数据库，然后告诉用户领取成功即可。

    当然，前面说的这种办法也存在一个问题，就是可能需要多次与Redis交互。因此还有一种思路就是利用Redis的LUA脚本来编写校验逻辑来代替java编写的校验逻辑。这样就只需要向Redis发一次请求即可完成校验。

22. 

##### 12优惠券使用

1. 优惠券的使用流程就是下单购物的流程；抽象一个接口来标示优惠券规则(策略模式)：1判断是否可用；2按照优惠规则计算优惠金额；3生成优惠券规则描述；定义四个实现类
2. **优惠券智能推荐**流程：1查询用户所有可用优惠券；2初筛，计算总额判断优惠券是否可用；3排列组合找出所有方案(1细筛，找出每一个优惠券的可用的课程判断是否可用；2回溯全排列优惠券的顺序+单个优惠券；3计算方案的优惠明细；4筛选最优解)
3. 券叠加算法：构建商品优惠明细，记录每个商品优惠金额，然后分别遍历优惠券，逐步计算叠加后的每一个课程的优惠金额；最后返回的是优惠券id，优惠券折扣规则说明，优惠总金额
4. CompleteableFuture并发计算：对于回溯计算的优惠券顺序全排列方案，串行计算导致性能较低，使用多线程并行计算，两个难点：1线程任务是带返回值的任务；2多线程任务需等待所有线程执行完毕后才返回结果
5. 解决方法：1CompletableFuture.supplyAsync(异步执行代码).thenAccept(记录返回值)；2CountDownLatch(JUC包工具)，计数器，线程执行完毕减一，为零时即所有线程执行完毕
6. 筛选最优解：构建两个map，记录  用券相同时优惠金额最高的方案，优惠金额相同时用券数量最少的方案，取交集即最优解
7. **面试**：1优惠券规则是如何编码实现的：基于策略模式来实现，接口中实现了1判断是否可用；2按照优惠规则计算优惠金额；3生成优惠券规则描述 三种方法
8. 设计模式的使用：在基于注解的通用分布式锁组件中使用了工厂模式和策略模式，优惠券功能使用了策略模式来定义优惠规则
9. 线程池/并发编程的使用：实现优惠券的推荐算法时，采用的是排列组合多种优惠方案，然后分别计算筛选出最优解；由于需要计算的优惠方案较多，为了提升计算效率，利用CompletableFuture来实现多方案的并行计算。并且由于要筛选最优解，那就需要等待所有方案都计算完毕，再来筛选。因此就使用了CountdownLatch来做多线程的并行控制。
10. 多个商品使用优惠券时，如果出现部分退款的情况，如何处理退款金额，优惠券如何处理：1基于产品的需求，采用不退券的方案；2只退部分商品，按照实付金额来退款，







##### password

1. 192.168.150.101    
2. 用户端  http://www.tianji.com (jack/123    rose/123456)
3. 管理端  http://manage.tianji.com
4. VM:  root 123321
5. Nacos:  nacos  nacos
6. RabbitMQ:  tjxt  123321
7. MySQL:  root  123
8. redis:  auth  123321(只有密码没有用户名，auto相当于是命令)
9. Git:  tjxt  123321
10. Jenkins  root  123
11. xxl-job  admin  123456

