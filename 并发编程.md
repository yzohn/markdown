### 并发编程

#### Synchronized/ReentrantLock 

1. 创建线程：new Thread(Runnable, name)    new Thread(FutureTask<>, name)可以获取返回值
2. runnable和callable区别，runnable没有返回值，且实现的run方法异常必须在内部处理，不能抛出
3. Thread方法，interrupt；打断sleep的线程，会清空打断状态False；打断正常运行的线程则不会清空打断状态True
4. 守护线程  setDaemon(true)
5. JAVA API的六种状态：new, runnable(包含就绪，运行，阻塞), blocked(阻塞进入synchronized的代码), waiting(需要显示被唤醒), time_waiting, terminated
6. 线程共享导致多个线程在临界区执行，由于代码的执行序列不同而导致结果无法预测，竞态条件
7. 避免竞态条件：阻塞式解决方案: synchronized, Lock;  非阻塞式: 原子变量
8. synchronized：俗称对象锁，采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程就会被阻塞住，保证拥有锁的线程可以安全执行临界区的代码，不用担心线程上下文切换；实际上是用对象锁的方式保证了临界区代码的原子性
9. synchronized加在方法上等价于synchronized(this); 加在静态方法上等价synchronized(Test.class)
10. 常见线程安全类：String，Integer(不可变的类其方法都是线程安全的)，StringBuffer, Random, Vector, HahsTable, concurrent
11. 查看变量是否会在各个进程之间共享
12. Java对象头结构：Mark Word(hashcode,age,biased_lock或者指向Monitor的指针,state) + Klass Word(指向对应的Class对象)；所以一个对象的结构=对象头+实例数据+对齐填充
13. 对象头的 Mark Word 中就被设置为指向 Monitor 对象的指针，Monitor的owner指针再指向进程，也就是说Monitor是独立的，是介于锁对象和线程之间的独立个体；Lock Record则是包含在线程里面的，为线程所有
14. Monitor(监视器，管程)：使用synchronized给对象加锁后，该对象的Mark Word会有指向操作系统提供的Monitor的指针，Monitor(包括Owner, EntryList阻塞队列, WaitSet之前获得锁但条件不满足)，owner会指向当前进程，同一时刻只能有一个owner
15. 使用轻量级锁对事件错开的加锁线程就绪优化，语法仍然是synchronized保持不变；步骤：每个线程都会包括锁记录的结构，让锁记录的Object reference指向对象，并尝试用cas替换Object对象的Mark Word，并将Mark Word存入锁记录，如果替换成功，被锁的对象的对象头储存的是锁记录的地址和状态00表示轻量级锁；cas失败，1如果有竞争，进行自旋锁，一定次数后锁膨胀；2如果是自己重复进锁(函数嵌套使用锁方法)，Lock Record加一
16. 锁膨胀：为对象申请Monitor锁，让Object指向重量级锁地址，然后自己进入EntryList变成blocked状态，当Thread退出synchronized同步块后，使用cas将Mark Word的值恢复给对象头，解锁
17. 自旋优化：自旋的过程持锁的线程释放了锁，那么当前线程就可以不进行上下文切换就获得锁(适用于多核CPU 循环等待)
18. 偏向锁：针对同一线程重复入锁的情况, 只有第一次使用cas操作时将对象的Mark Word设置为偏向线程ID，之后发现线程ID是自己的(函数嵌套使用锁方法)就不再进行cas(compare and swap)
19. 都是JVM对synchronized锁的优化，包括轻量级锁，重量级锁，偏向锁；减少锁的竞争带来的用户态与内核态之间的切换；
20. 对于 synchronized 锁来说，锁的升级主要是通过 Mark Word 中的锁标记位(无，偏向(线程ID)，轻量(锁记录)，重量(Monitor))与是否是偏向锁标记为来达成的；
21. synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。
22. 锁对象调用wait方法(Object方法)，会使当前进程进入WaitSet中，变成waiting状态(已经获得锁但条件不满足)，只有其他获得锁的对象调用notify/notifyAll方法才会被唤醒
23. sleep是Thread的静态方法，在阻塞时不会释放锁，不需要与synchronized一起使用；wait是Object方法，在阻塞时会释放锁，需要与synchronized一起使用，还需搭配notify
24. LockSupport.park&unpark: 暂停/恢复线程的运行(理解：背包，帐篷，干粮，干粮耗尽就休息，从组就继续前进)
25. 线程状态转换：runnable–>waiting:  wait, join, park;    –>timed_waiting所有加时间包括sleep
26. 活跃性：线程因为某些原因，代码一直无法执行完毕；包括死锁，活锁，饥饿
27. 死锁：在线程使用锁对象时，顺序加锁即可避免死锁
28. 活锁：两个线程互相改对方的结束条件，谁也无法结束；避免活锁方法：中途给予不同的时间间隔即可；  与死锁区别：死锁是互相持有对方想要的锁都不释放，最后线程阻塞，停止运行；而活锁是互相修改对方结束条件，代码一直在运行但是运行不完
29. 饥饿：某些线程因为优先级太低，导致一直无法获得资源；在使用顺序加锁时可能会出现饥饿
30. ReentrantLock可重入锁：  和synchronized的区别：可中断，可以设置超时时间，可以设置为公平锁(先到先得)，支持多个条件变量(具有多个WaitSet)
31. 特点：1可重入(拥有者有权再次获取这把锁)； 2可打断(处于阻塞状态的线程被打断t1.interrupt，直接停止运行，lock.lockInterruptibly)；锁超时：获取锁失败了/获取超时了或者被打断了，不再阻塞直接停止运行  tryLock   3公平锁:new ReentrantLock(true)     4条件变量：支持多种不同条件的waitSet(ReentrantLock.newCondition.await/signal)
32. 同步模式值顺序控制：1wait/notify  2park/unpark  3await/signal

#### JMM/CAS/Volatile

1. Java 内存模型（Java Memory Model）是一种抽象的模型，简称 JMM，主要用来定义多线程中变量的访问规则，用来解决变量的可见性、有序性和原子性问题，确保在并发环境中安全地访问共享变量。
2. 定义了一套在多线程读写共享数据(成员变量，数组)时，对数据的可见性，有序性，原子性的规则和保障 Java Memory Model
3. 原子性(i++由执行引擎里多个指令执行)–不受线程上下文切换的影响； 可见性：不受cpu缓存的影响(即时编译)； 有序性：不受cpu指令并行优化的影响(JVM优化指令重排)
4. 可见性+volatile     synchronized既保证原子性，也保证代码块内变量的可见性，但性能较低
5. volatile修饰的变量可以禁止指令重排，禁止该变量之前的代码重排序     
6. volatile原理：内存屏障，对volatile变量的写指令后加入写屏障，读指令前加入读屏障；把volatile变量的改动以及的代码普通变量改动都会同步到主存当中，读屏障加载的是主存当中的最新数据(读取的是那些普通变量)   写是ready=true; 读是if(read)
7. volatile保证有序性：不会将写屏障之前的代码排在写屏障之后，不会将读屏障之后的代码排在读屏障之前；只能保证本线程的代码不被重排序，不能解决线程间的指令交错
8. CAS(compare and Set/Swap) 乐观锁的思想，不断尝试直到成功(判断共享变量有没有更改再进行修改操作，如果更改就重新获取共享变量的值)；适用于竞争不激烈，多核CPU场景，
9. CAS必须借助volatile才能读取到共享变量的最新值来实现比较并交换的效果；效率高：线程一直再运行，不会像Synchronized发生上下文切换进入阻塞；但如果竞争激烈(写操作多)，重试必然频繁发生，反而效率会受影响
10. 乐观锁思想：改了没关系，自己吃点亏；  悲观锁(sychronized):防着别人改

#### 线程池

1. 好处：降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的损耗；提高响应速度，提高线程的可管理性：线程是稀缺资源，如果无限制的创建不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行同一的分配调优和监控
2. 自定义线程池：Thread Poll, Blocking Queue阻塞队列保存的是被阻塞的任务
3. Blocking Queue定义的是阻塞队列dequeue，以及满/空的休息队列Condition，带时间/不带时间的添加获取；以及将处置阻塞队列满了的函数式接口方法rejectPolicy(策略模式)交给调用者的添加方法；
4. 拒绝策略：阻塞队列也满了的时候怎么做，方法下放给调用者；1死等(condition.await); 2超时等待；3放弃执行；4抛出异常；5调用者自己执行
5. 线程池定义的是一个线程集合HashSet\<Worker>, Worker是参数为Runnable的Thread子类；线程池没满就创建线程并start, 线程执行完成后会判断Blocking Queue是否还有阻塞的线程执行完
6. ThreadPoolExecutor:  线程池状态：用int的高三位表示线程池状态，低29位表示线程数量(可以通过一次CAS操作同时更改两个属性的值)
7. 构造方法(核心线程数，最大线程树(核心+救急线程数)，救急线程空闲时的最大生存时间，时间单位，阻塞队列(有界/无界/最多只有一个同步元素的队列__一手交钱一手交货)，优先队列，线程工厂(给线程起名字)，拒绝策略handle)   7个参数
8. Executors类提供了4个静态方法：newCachedThreadPool()、newFixedThreadPool(int)、newSingleThreadExecutor和newScheduledThreadPool(int)；都是对ThreadPoolExecutor的调用
9. Cached:线程创建数量不限制，空闲会自动终止线程；Fixed:空闲时依然不释放；Schedule支持定时及周期性任务执行；Single：单线程，保证按照指定顺序(FIFO/优先级等)

#### AQS

1. Abstract Queued Synchronizer(抽象队列同步器)，是阻塞式锁和相关的同步器工具的框架，定义了锁的实现机制，并开放出扩展的地方，让子类去实现，AQS 底层由同步队列 + 条件队列联手组成
2. 特点：1用state属性来表示资源的状态(分为独占模式state=1和共享模式)，子类需要定义和维护getState, setState，compareAndSetState：CAS机制设置state状态；2提供了基于FIFO的等待队列，类似于Monitor的EntryList；3条件变量condition来实现等待、唤醒机制，支持多个条件变量，类似于Monitor的WaitSet
3. 自定义锁，其实就是在自定义锁类内部再声明AQS类，重写tryAcquire{compareAndSetState(0,1){setExclusiveOwnerThread}}，try(release)就是用CAS加锁/释放锁；newCondition, isHeldExclusively{getState()==1}，然后其他加锁(可中断，带超时时间，仅尝试一次)方法都调用AQS的方法；AQS 围绕两个队列，提供了四大场景，分别是：获得锁、释放锁、条件队列的阻塞，条件队列的唤醒
4. ReentrantLock提供了两个同步器，实现公平锁和非公平锁，默认是非公平锁(NofairSync继承自AQS)
5. 非公平锁实现原理：加锁：对象
6. 同步队列和条件队列，分别就是Sync和ConditionObject
7. NonfairSync(state, head, tail, exlusiveOwnerThread)，头尾节点为entryList的头尾节点，头节点是Dummy哨兵，用来占位；不公平体现在FIFO的第一个节点可能会和刚刚尝试获得锁的新人一起竞争
8. 条件变量实现原理：每个条件变量对于一个等待队列waitSet，实现类是ConditionObject(firstWaiter, lastWaiter)，被唤醒后重新在等待队列排队
9. AQS资源共享模式分为独占模式和共享模式
10. JUC 中的许多并发工具类和接口都是基于 AQS 实现的。它提供了一种基于队列的、高效的、可扩展的同步机制，是实现锁、信号量、倒计时器等同步器的基础。

#### 面试小抄

1. 其实Thread也就是实现了Runnable接口，提供了更多的方法而已。所以说Thread与Runnable并没有什么区别。如果硬要说有什么区别的话，那就是类与接口的区别，继承与实现的区别。用法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简单的执行一个任务，那就实现runnable。(错误结论：Runnable便于实现资源共享，Thread不能；MyThread t1 = new MyThread();        new Thread(t1).start();        new Thread(t1).start()可以实现资源共享)
2. Runnable和Callable的区别：call(), run(); Callable可以返回值，可以抛出异常
3. 调用start方法，会启动一个线程使线程进入就绪状态，当分配到时间片就可以开始运行了，而run方法只是thread的一个普通方法，还是在主线程里执行
4. CAS：全称 Compare and swap，即比较并交换，它是一条 CPU 同步原语。是一种硬件对并发的支持，针对多处理器操作而设计的一种特殊指令，用于管理对共享数据的并发访问；是一种无锁的非阻塞式算法的实现
5. CAS问题：ABA问题，循环时间长开销，只能保证一个变量的原子操作
6. synchronized和volatile的区别：volatile解决的是内存可见性问题，会使得所有对volatile变量的读写都直接写入内存，保证了变量的可见性；synchronized解决的是执行控制的问题，除了阻止其他线程获得对象锁，还会创建一个内存屏障，保证CPU操作结果页都会直接刷新到主存中
7. 1volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
   2volatile 仅能使用在变量级别；synchronized 则可以使用在 变量. 方法. 和类级别的
   3volatile 仅能实现变量的修改可见性，不能保证原子性；而synchronized 则可以 保证变量的修改可见性和原子性
   4volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
   5volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。
8. synchronized和lock的区别：synchronized可以给类，方法，代码块加锁；不需要手动释放锁，发生异常会自动释放锁，不会造成死锁；通过lock可以直到有没有成功获得锁；synchronized依赖于JVM，ReentrantLock是JDK层面上的，依赖于API(lock unlock)
9. ReentrantLock可重入锁：  和synchronized的区别：可中断，可以设置超时时间，可以设置为公平锁(先到先得)，支持多个条件变量
10. synchronized非公平锁体现在哪：持有锁的线程释放锁时，会将monitor的owner赋值为null，然后唤醒等待链表的一个线程；1如果此时有其他线程刚好在尝试获得锁(如自旋锁)，则可以马上获得锁；2放入链表的顺序，和最终被唤醒的顺序是不一致的，也就是说你先进入链表，不代表你就会先被唤醒
11. synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。
12. 对象头的 Mark Word 中就被设置为指向 Monitor 对象的指针，Monitor的owner指针再指向进程，也就是说Monitor是独立的，是介于锁对象和线程之间的独立个体；Lock Record则是包含在线程里面的，在线程内部直接和锁对象沟通(交换Mark Word)；偏向锁就是将对象的 Mark Word 头设置为偏向线程 ID
13. 总结就是围绕锁对象的Mark Word，依次设置线程ID，用线程创建的Lock Record对象去交换，用Monitor做中介
14. 自旋和cas不是一回事儿，只是在cas的时候可以利用自旋机制来不断重试
15. Synchronized和ReentrantLock的区别：1都是可重入锁；2syn依赖于JVM实现，Re是JDK层面实现的；3Re增加了一些高级功能：可打断，可设置超时时间，可以指定是公平还是非公平锁，多个条件队列

#### ThreadLocal

1. ThreadLocal即线程本地变量，创建一个ThreadLocal变量，访问这变量的每个线程都会由一份拷贝，操作变量实际上都是在操作本地内存的变量，从而起到线程隔离的作用，避免并发场景下的线程安全问题

2. 实现原理：

   Thread线程类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，即每个线程都有一个属于自己的ThreadLocalMap。

   ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是线程的局部变量本身。

   并发多线程场景下，每个线程Thread，在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而可以实现了线程隔离。

3. Entry 继承了 WeakReference，它限定了 key 是一个弱引用，弱引用的好处是当内存不足时，JVM 会回收 ThreadLocal 对象，并且将其对应的 Entry 的 value 设置为 null，这样在很大程度上可以避免内存泄漏。

4. 内存泄漏问题：通常情况下，随着线程 Thread 的结束，其内部的 ThreadLocalMap 也会被回收，从而避免了内存泄漏。

   但如果一个线程一直在运行，并且其 `ThreadLocalMap` 中的 Entry.value 一直指向某个强引用对象，那么这个对象就不会被回收，从而导致内存泄漏。当 Entry 非常多时，可能就会引发更严重的内存溢出问题。

5. 解决方法：使用完 ThreadLocal 后，及时调用 `remove()` 方法，将当前线程的 ThreadLocalMap 中的所有 key 为 null 的 Entry 全部清除，释放内存空间。

6. 使用ThreadLocal发生内存泄漏的原因可能是：

   1. ThreadLocalMap 的生命周期过长，在使用线程池等长生命周期的线程时，线程不会立即销毁。

      如果ThreadLocal变量在使用后没有被及时清理（通过调用ThreadLocal的remove()方法），那么ThreadLocalMap中的键值对会一直存在，即使外部已经没有对ThreadLocal对象的引用。

      这意味着ThreadLocalMap中的键值对无法被垃圾收集器回收，从而导致内存泄露。

   2. ThreadLocal 对象生命周期结束，线程继续运行。

      如果一个ThreadLocal对象已经不再被使用，但是线程仍然在运行，并且其ThreadLocalMap中还保留着对这个ThreadLocal对象的键的引用，这会导致ThreadLocal对象所引用的数据也无法被回收，因为ThreadLocalMap中的键是对ThreadLocal对象的弱引用（WeakReference），但值（存储的数据）是强引用。









7. ThreadLocalMap使用ThreadLocal的弱引用作为key，当ThreadLocal变量被手动设置为null，即一个ThreadLocal没有外部强引用来引用它，当系统GC时，ThreadLocal一定会被回收。这样的话，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话(比如线程池的核心线程)，这些key为null的Entry的value就会一直存在一条强引用链：Thread变量 -> Thread对象 -> ThreaLocalMap -> Entry -> value -> Object 永远无法回收，造成内存泄漏



























