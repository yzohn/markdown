#### 面经

1. 进程间的管道通信：

   1. 管道，内核中的一串缓存，从管道的一端写入数据，另一端读取，数据只能单向流动，遵循先进先出的原则；分为匿名管道(具有亲缘关系的进程如父子进程)，和命名管道(允许无亲缘关系的进程通信)；管道的效率低，不适合进程间频繁地交换数据
   2. 信号：用于通知接受进程某件事情发生了，主要用于处理异步事件
   3. 消息队列：保存在内核的消息链表，按照消息的类型就行消息传递，具有较高的可靠性和稳定性；缺点：消息体有一个最大长度的限制，不适合比较大的数据传输，存在用户态和内核态之间的数据拷贝开销
   4. 共享内存：一个给定的内存区，一个进程写入的东西其他进程马上能看到，最快的进程间通信方式，针对其他通信方式运行效率低设计的；缺点：当多进程竞争同一个共享资源时，会造成数据错乱的问题
   5. 信号量：本质上是一个计数器，用来控制对共享资源的访问数量；PV操作
   6. 套接字Socket：提供网络通信的端点，可以让不同机器上运行的进程之间进行双向通信

2. 工厂模式属于创建型设计模式，主要用于创建对象，而不暴露创建对象的逻辑给客户端； 简单工厂只有一个工厂类，产品对象通常属于同一类别(直接getProduct)；而抽象工厂则有多个工厂类，每个工厂类负责创建一组相关的对象，可以创建不同类别的产品对象(先getFacotry后getProduct);应用场景：1数据库访问层组件：提供统一的接口获取不同的数据库连接；2日志记录，实现多种日志记录方法动态决定

3. 单例模式：创建型设计模式，确保一个类只有一个实例，提供一个全局访问点来获取该实例；用于控制对某些共享资源的访问，如线程池

4. TCP可靠传输：校验和，序列号和确认应答，滑动窗口，超时重传，流量控制、拥塞控制

5. UDP可靠传输的实现：1确认机制ACK，2超时重传，3重排机制：增加缓冲区数据重排，4流量控制

   1重传机制，丢包需要进行重传，可以用ACK也可以用NACK的方式；2是重排机制，我们在收到乱序数据一定需要增加一个缓冲区进行数据重排；3超时机制，长时间没收收到对方的回复需要进行重试；4流量控制



1. SQL优化：1避免不必要的列(select \*)；2分页优化；3索引优化；4JOIN优化；5排序优化；6UNION优化
2. 索引优化：1使用覆盖索引；2避免使用!=或者<>操作符；3适当使用前缀索引；4避免列上使用函数；5正确使用联合索引；(就是避免索引失效的情况)
3. JOIN优化：1优化子查询(join代替子查询，子查询相当于查两次)；2小表驱动大表(A left join B，A表小于B表，建立连接的次数少，查询速度快)；3适当增加冗余字段，来避免join操作；4避免使用join关联太多表(不超过3个)
4. 排序优化：利用索引扫描做排序(select name order by name)
5. 索引为什么能加快查找速度：数据库文件是存储在磁盘上的，磁盘IO是数据库操作最耗时的部分之一，没有索引会使用全表扫描，读取表中的每一行数据来查找匹配的行，有了索引不必扫描整张表，大大减少IO的操作次数
6. 聚集索引：表中的行是按照索引的顺序存储的，意味着表中的实际数据行和键值之间存在物理排序的关系，每个表只能有一个聚集索引(也就是主键，主键是按照顺序在聚集索引里排列的)；非聚集索引中，索引和数据是分开存储的，索引中的键值指向数据的实际存储位置
7. 聚集索引：叶子节点中存放的就是整张表的行记录数据；非聚集索引叶子节点存储的不再是行的物理位置，而是主键值或地址
8. 聚集索引就是以主键创建的索引，在叶子节点存储的是表中的数据；非聚集索引就是以非主键创建的索引，在叶子节点存储的是主键和索引列
9. 如何优化对一个大表和小表的关联查询：1为关联字段建立索引；2小表驱动大表



1. 事务的传播行为：定义了在方法被另一个事务方法调用时该怎么做，Spring默认required：如果当前存在事务则加入，当前不存在则创建一个新的事务
2. springboot简化了spring的配置，开发人员只需要通过注解即可搭建基本的应用程序，提升开发效率；内嵌服务器，Tomcat、Jetty，使得应用程序可以直接运行不需要单独部署；提供即开即用的脚手架，可以根据自己的需求选择对应的依赖库生成应用程序的基本骨架；简化搭建，采用自动装配机制，减少了手动配置，同时也可以简化多模块之间的构建
3. 为什么需要HandleAdapter：其主要职责是调用Handle的方法来处理请求，并且适配不同类型的处理器，可以确保DespatcherServlet可以用统一的方式调用不同类型的处理器，无需关心具体的指向细节



1. Concurrenthashmap：也是数组+链表+红黑树的结构，在锁的实现上，采用CAS+synchronized实现更加低粒度的锁，将锁的级别控制在哈希桶元素级别，只需要锁住头节点，不影响其他哈希桶元素的读写，大大提高并发性
2. 对于读操作，通常不需要加锁，可以直接读取，内部使用了volatile变量(元素+指针)来保证内存可见性
3. 对于写操作：1根据key计算hash值；2判断是否需要初始化；3定位拿到Node，拿到首节点并判断：如果为null，则用CAS的方式尝试添加；如果f.hash=-1其他线程在扩容则一起参与；如果都不满足，synchronized锁住头节点，遍历插入；4链表长度达到8时进行数组扩容或转换为红黑树
4. find基本上相当于 linux下的 “搜索” , 相当于windows下的搜索功能! 它是用来搜索文件的。
   grep是用来搜索文本的, 用来在standard input或文件内部的内容中, 来搜索文字 内容的!
   find 是完全匹配（通配符），而grep是包含匹配（正则表达式）



1. 乐观锁和悲观锁：悲观锁认为每次访问共享资源时会发生冲突，所以对每次数据操作都上锁，以保证临界区的程序同一时间只能有一个线程在执行；乐观锁假设对共享资源的访问没有冲突，无需加锁无需等待，一旦多个线程发生冲突，通常使用CAS的技术来保证线程执行的安全性
2. ABA问题可以使用版本号/时间戳的方式来解决，不仅要求值匹配，还要求版本号匹配
3. 启动一个Java程序，存在几个线程：首先是main线程，是程序开始执行的入口；然后是垃圾回收线程，是一个后台线程，负责回收不再适用的对象；还有编译器线程，在即时编译器JIT中，负责把一部分热点代码编译后放到codeCache中，提升程序的执行效率；
4. 哪些对象会加入老年代：1长期存活的对象；2大对象直接加入老年代，避免在年轻代中频繁复制大对象；3动态对象年龄判定，除了固定的年龄阈值，还有动态调整对象的晋升策略
5. young gc是指发生在年轻代(包含伊甸园和两个幸存区)的垃圾收集；full gc是最彻底的垃圾回收，涉及整个java堆和方法区，是最耗时的gc，通常在JVM压力很大时发生
6. G1 把 Java 堆划分为多个大小相等的独立区域（Region），每个区域都可以扮演新生代（Eden 和 Survivor）或老年代的角色；还有专门为大对象设计的 Region，叫 Humongous 区；这种区域化管理使得 G1 可以更灵活地进行垃圾收集，只回收部分区域而不是整个新生代或老年代
7. G1：1初始标记；2并发标记；3最终标记(对用户线程短暂暂停)；4清理阶段(必须暂停用户线程，多条回收器线程并行完成)：
8. 清理阶段：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。



1. JVM的垃圾回收器主要分为两类：分代垃圾回收(CMS)和分区垃圾回收(G1，ZGC)；
2. 对象创建：使用new创建对象时，首先JVM会检查是否能在常量池定位到一个类的符号引用，然后检查是否被加载，验证，准备，解析，初始化；准备包括分配内存和复制，还要设置对象头，对象头包含了哈希值，gc分代年龄，属于哪个类等信息；初始化是调用构造方法，将成员变量赋值为预期的值
3. 对象的销毁：当对象不再被任何引用指向时，对象就会变成垃圾；通过可达性分析方法判断对象是否存活，如果不可达就会被回收；垃圾回收器通过标记清除，标记整理，标记复制等算法来回收内存；常见的垃圾收集器有CMS，G1，ZGC等，它们的回收策略和效率不同，可以根据具体的场景选择合适的垃圾回收器
4. volatile内存屏障：对volatile变量进行写操作时，会插入写屏障指令，强制将本地内存中的变量刷新到主内存中；进行读操作时，JMM会插入读屏障指令，这个指令会强制让本地内存中的变量值失效，从而重新从主内存中读取最新的值
5. http请求报文：请求行(包括方法get/post, URL, HTTP协议版本)；请求头(键值对，包含请求的附加信息，如Host主机名，浏览器类型，客户端想要接收的内容类型Accept: text/html)；请求体
6. 响应报文：状态行(HTTP协议版本，状态码，状态消息ok/notfount)，响应头(服务器类型，内容类型，内容长度，资源过期时间)；响应体(响应的具体内容，如HTML界面)
7. OOM内存泄漏：是指程序在使用完内存后，未能释放已分配的内存空间，导致这部分内存无法再被使用，随着时间推移，内存泄漏会导致可用内存逐渐减少，最终可能导致内存溢出；包括栈溢出，元空间溢出，堆内存溢出(一次性创建了大量对象)



1. 为什么选择B+树：
   1. 更高效的磁盘IO，减少了磁盘寻道时间和页的加载次数(矮胖，每次搬的砖更多，减少读写的次数)
   2. 支持范围查询，与 B 树相比，B+树的叶子节点通过指针连接成一个链表，这使得范围查询变得非常高效。在 B+树上执行范围查询可以简单地从范围的起始点开始，然后沿着链表向后遍历，直到结束点。
   3. 查询性能稳定，B+树的所有查找操作都要查到叶子节点，这使得所有的查询操作都有着相同的访问深度，因此查询性能非常稳定。不像某些其他数据结构，如 B 树，其查询性能因为数据存在所有的节点上导致深度不一致，性能不稳定。



1. 读提交和可重复读是通过MVCC机制中的ReadView实现的，读提交每次读取数据前都会生成一个ReadView，保证每次读操作都是最新的数据；可重复读只在第一次读操作时生成ReadView，后序读操作都是使用这个，保证事务内读取的数据是一致的

2. 串行化强制要求事务排序，事务在读操作时，必须先加表级共享锁，知道事务结束才释放；在写操作时，必须先加表级排他锁，知道事务结束才释放

3. HTTP3.0和2.0的区别：1 2.0基于TCP协议，3.0基于QUIC协议，直译为快速UDP网络连接；2基于TCP的2.0尽管从逻辑上来说，不同流之间相互独立不会互相影响，但在实际传输过程中，一旦某一个流的数据有丢包，仍然会阻塞在它之后传输的流数据；   而基于UDP的QUIC协议可以更彻底地解决这样的问题，让不同流之间真正的实现相互独立传输，互不干扰；3QUIC协议在传输的过程中就完成了TLS加密握手，更直接了

4. 主从复制（Master-Slave Replication）：允许一个 Redis 服务器（主节点）将数据复制到一个或多个 Redis 服务器（从节点）。这种方式可以实现读写分离，适合读多写少的场景。

   哨兵模式（Sentinel）：用于监控主节点和从节点的状态，实现自动故障转移和系统消息通知。如果主节点发生故障，哨兵可以自动将一个从节点升级为新的主节点，保证系统的可用性。

   集群模式（Cluster）：Redis 集群通过分片的方式存储数据，每个节点存储数据的一部分，用户请求可以并行处理。集群模式支持自动分区、故障转移，并且可以在不停机的情况下进行节点增加或删除。

5. 编程式事务管理：需要在代码中显式调用事务管理的 API 来控制事务的边界，比较灵活，但是代码侵入性较强，不够优雅。

6. 声明式事务管理：@Transactional  这种方式使用 Spring 的 AOP 来声明事务，将事务管理代码从业务代码中分离出来。优点是代码简洁，易于维护。但缺点是不够灵活，只能在预定义的方法上使用事务。

7. 

   

1. SpringBoot的自动装配：可以自动配置和加载 Spring Boot 所需的各种组件和功能，从而大大的减少开发人员手动配置的工作。不需要像Spring一样手动配置各种组件，如数据源、Web 容器、事务管理器等。这些配置需要编写大量的 XML 配置文件或 Java 配置类，增加了开发的工作量和复杂性
2. Spring Boot 的自动装配原理依赖于 Spring 框架的依赖注入和条件注册，通过这种方式，Spring Boot 能够智能地配置 bean，并且只有当这些 bean 实际需要时才会被创建和配置。



1. 在 Spring 中，自动装配是指容器利用反射技术，根据 Bean 的类型、名称等自动注入所需的依赖；在SpringBootzhong ,开启自动装配的注解是@EnableAutoConfiguration，进一步简化包含在@SpringBootApplication注解中
2. Spring Boot 的自动装配原理依赖于 Spring 框架的依赖注入和条件注册，通过这种方式，Spring Boot 能够智能地配置 bean，并且只有当这些 bean 实际需要时才会被创建和配置。



1. ZSet的底层原理：listpack(取代ziplist)，调表skiplist；
2. 跳表（skiplist）是一种有序的数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。
3. listpack 是 Redis 用来替代压缩列表（ziplist）的一种内存更加紧凑的数据结构。为了避免 ziplist 引起的连锁更新问题，listpack 中的元素不再像 ziplist 那样，保存其前一个元素的长度，而是保存当前元素的编码类型、数据，以及编码类型和数据的长度。



1. 线程池的工作流程：

   1. 当应用程序提交一个任务时，线程池会根据当前线程的状态和参数决定如何处理这个任务。

      - 如果线程池中的核心线程都在忙，并且线程池未达到最大线程数，新提交的任务会被放入队列中进行等待。
      - 如果任务队列已满，且当前线程数量小于最大线程数，线程池会创建新的线程来处理任务。

      空闲的线程会从任务队列中取出任务来执行，当任务执行完毕后，线程并不会立即销毁，而是继续保持在池中等待下一个任务。

      当线程空闲时间超出指定时间，且当前线程数量大于核心线程数时，线程会被回收。



1. TreeMap 通过 key 的比较器来决定元素的顺序，如果没有指定比较器，那么 key 必须实现 Comparable 接口；底层是红黑树，红黑树是一种自平衡的二叉查找树，每个节点都大于其左子树中的任何节点，小于其右子节点树种的任何节点。插入或者删除元素时通过旋转和着色来保持树的平衡；

2. TreeMap 是基于红黑树实现的，put 元素的时候会先判断根节点是否为空，如果为空，直接插入到根节点，如果不为空，会通过 key 的比较器来判断元素应该插入到左子树还是右子树。get 元素的时候会通过 key 的比较器来判断元素的位置，然后递归查找

3. 由于 HashMap 是基于哈希表实现的，所以在没有发生哈希冲突的情况下，HashMap 的查找效率是 O(1)。适用于查找操作比较频繁的场景。

   而 TreeMap 是基于红黑树实现的，所以 TreeMap 的查找效率是 O(logn)。并且保证了元素的顺序，因此适用于需要大量范围查找或者有序遍历的场景。



1. 使用ThreadLocal发生内存泄漏的原因可能是：

   1. ThreadLocalMap 的生命周期过长，在使用线程池等长生命周期的线程时，线程不会立即销毁。

      如果ThreadLocal变量在使用后没有被及时清理（通过调用ThreadLocal的remove()方法），那么ThreadLocalMap中的键值对会一直存在，即使外部已经没有对ThreadLocal对象的引用。

      这意味着ThreadLocalMap中的键值对无法被垃圾收集器回收，从而导致内存泄露。

   2. ThreadLocal 对象生命周期结束，线程继续运行。

      如果一个ThreadLocal对象已经不再被使用，但是线程仍然在运行，并且其ThreadLocalMap中还保留着对这个ThreadLocal对象的键的引用，这会导致ThreadLocal对象所引用的数据也无法被回收，因为ThreadLocalMap中的键是对ThreadLocal对象的弱引用（WeakReference），但值（存储的数据）是强引用。



1. 对一致性要求很高，应该怎么做：  不一致的原因主要是1缓存删除失败；2并发导致写入了脏数据
   1. 引入消息队列保证缓存被删除 ；  当数据库更新完成后，将更新事件发送到消息队列。有专门的服务监听这些事件并负责更新或删除缓存
   2. 数据库订阅+消息队列保证缓存被删除；  监听MySQL的binlog，订阅该消息进行缓存删除
   3. 延时双删防止脏数据；  在第一次删除缓存之后，过一段时间之后，再次删除缓存；主要针对缓存不存在，但写入了脏数据的情况。在先删缓存，再写数据库的更新策略下发生的比较多
   4. 设置缓存过期时间兜底；  这是一个朴素但有用的兜底策略，给缓存设置一个合理的过期时间，即使发生了缓存和数据库的数据不一致问题，也不会永远不一致下去，缓存过期后，自然就一致了
2. 怎样保证二级缓冲和Redis缓存的数据一致性：数据发送变化时直接删除Redis中的数据就行；保证本地缓存和Redis缓存的一致性策略：
   1. 设置本地缓存的过期时间，当本地缓存过期时，就从Redis缓存中同步数据，最简单最直接；
   2. 使用Redis的Pub/Sub机制，当Redis缓存发生变化时，发布一个消息，本地缓存订阅这个消息，然后删除对应的本地缓存；
   3. Redis缓存发生变化时，引入消息队列区更新本地缓存





1. gc root包括 1虚拟机栈中的引用（方法的参数、局部变量等）2本地方法栈中 JNI 的引用   3类静态变量
   4运行时常量池中的常量（String 或 Class 类型）
2. 浏览器接收 HTTP 响应：浏览器接收到服务器返回的 HTTP 响应数据，开始解析响应体中的 HTML 内容；然后构建 DOM 树、解析 CSS 和 JavaScript 文件等，最终渲染页面。
3. MySQL的索引：数据结构分类：B+树索引，哈希索引；   存储位置：聚集索引，非聚集索引
4. 功能分类：主键索引，唯一索引，普通索引，全文索引
5. 主键索引: 表中每行数据唯一标识的索引，强调列值的唯一性和非空性；唯一索引：保证数据列中每行数据的唯一性，但允许有空值；  普通索引： 基本的索引类型，用于加速查询；  全文索引：特定于文本数据的索引，用于提高文本搜索的效率



1. 泛型的好处：1编译器类型安全(如果插入了其他类型的元素，在编译的时候就会报错，而不是等到运行时才抛出异常)；2避免了强制类型转换运行时异常；3同一个类可以操作多种类型数据，代码复用
2. 泛型的本质就是把类型参数化，所操作的数据类型被指定为参数，根据动态传入进行处理
3. 类型擦除的意思是指：泛型只在编译时起作用，运行时都当作object处理；由于类型擦除，所以当泛型方法被调用后编译器会额外插入一行指令用于强制类型转换，叫做泛型翻译



1. 线程同步的实现方式有 6 种：互斥量、读写锁、条件变量、自旋锁、屏障、信号量。
   - **互斥量**：互斥量（mutex）是一种最基本的同步手段，本质上是一把锁，在访问共享资源前先对互斥量进行加锁，访问完后再解锁。对互斥量加锁后，任何其他试图再次对互斥量加锁的线程都会被阻塞，直到当前线程解锁。
   - **读写锁**：读写锁有三种状态，读模式加锁、写模式加锁和不加锁；一次只有一个线程可以占有写模式的读写锁，但是可以有多个线程同时占有读模式的读写锁。非常适合读多写少的场景。
   - **条件变量**：条件变量是一种同步手段，它允许线程在满足特定条件时才继续执行，否则进入等待状态。条件变量通常与互斥量一起使用，以防止竞争条件的发生。
   - **自旋锁**：自旋锁是一种锁的实现方式，它不会让线程进入睡眠状态，而是一直循环检测锁是否被释放。自旋锁适用于锁的持有时间非常短的情况。
   - 信号量：信号量（Semaphore）本质上是一个计数器，用于为多个进程提供共享数据对象的访问。



#### 自我介绍

1. 我叫朱勇，是西安电子科技大学计算机技术专业的一名研二学生，我自学了一些java相关的技术栈，包括javaSE, springboot, mysql , redis, 消息中间件kafka，对jvm，java并发编程，操作系统，计算机网络都有一定的了解。同时自己也自学了一些基于springboot的个人项目，像论坛项目，除了用增删改查完成一些基本的登录注册发帖评论私信一些功能，还利用了一些中间件对项目进行优化和完善功能，包括redis, kafka, elasticsearch，大概就这些情况



荣耀，快手，百度，腾讯   智能院就业群

网易游戏 4.26新开；  滴滴4.28新开；  荣耀5.15截至投递  5.11倒数第二场笔试；  字节  ；   淘天5.15最后两场笔试；  阿里全系列